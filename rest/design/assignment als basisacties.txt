ASSIGNMENT AS BASIC ACTIONS
1. We hebben een beperkte verzameling assignment operatoren:
	a. maak of verwijder een context
	b. maak of verwijder een rol
	c. voeg een waarde toe aan een property of verwijder die
	d. bind een rol aan een andere rol
2. Elk van deze operatoren verandert de toestand (de logische feiten) op een volledig gedetermineerde manier. 
3. Operatoren b, c en d kunnen alleen voorwaardelijk worden uitgevoerd. Bijvoorbeeld: om een rol te kunnen maken, is een context nodig waarin die rol wordt toegevoegd.
4. Als je het uitgangspunt aanneemt dat elke context in een andere context moet worden ingebed, is operator a eveneens voorwaardelijk (alhoewel je kunt beargumenteren dat creeeren-en-binden een samengestelde operatie is). Ik ga in deze tekst ervan uit dat een context creeeren ook direct die context binden is.
5. We kunnen voor elke assignment operator een actie definiëren. Het instantiëren van zo'n actie leidt er dan eenmalig toe dat de betreffende assignment uitgevoerd wordt.
5. De voorwaarden nemen dan de vorm aan van het al dan niet beschikbaar zijn van het object of indirect object van de actie.
6. Deze objecten zijn het resultaat van een query. Die query kan zo eenvoudig zijn als het selecteren van een rol in de context van de actie.
7. Merk op dat dit het selecteren van het object van een omhullende actie omvat, als we toestaan dat een actie in een actie is ingebed.
8. Voor assignment van functionele rollen en properties geldt een aanvullende voorwaarde. Bij zulke assignment gaat het om het vullen van een locatie. De locatie moet leeg zijn. Tevens: om aan een rol te kunnen binden, moet die rol leeg zijn (dit geldt overigens niet als we meerdere bindingen van dezelfde rolinstantie toestaan). Verwar assignment niet met overschrijven of vervangen: acties die kunnen worden samengesteld uit verwijderen en vervolgens een waarde toekennen. 
9. We kunnen dus vaststellen dat assignment van relationele rollen en properties (en mogelijk rolbinding) onvoorwaardelijk is. Oftwel: geen van de assignment operatoren verandert iets aan de toestand waardoor assignment van een relationele rol of property mogelijk of onmogelijk wordt. 
10. Hoe is de cardinaliteit van de assignment actie-rollen? Dit zijn de rollen:
	a. creeer een context (object) in een contextRol (indirect object).
	b. Creeer een RolInContext of ContextRol (object) in een context (indirect object). 
	c. Voeg een waarde (object) toe aan een property (indirect object).
	c. Bind een rol (object) aan een andere rol (indirect object).
Ik kan voor alle vier use cases verzinnen voor relationele rollen. Voorbeelden:
	* creeer in elke contextRol in het indirect object een context;
	* voeg meerdere waarden toe aan één property
	* voeg dezelfde waarde toe aan meerdere properties
	enz.

IS DE UITKOMST GEDETERMINEERD?
De uitdaging is om te bepalen of een verzameling basisacties in een context een gedetermineerde uitkomst heeft.
Hoe zou een ongedetermineerd proces ontstaan?
Bijvoorbeeld zo: een functionele rol kan gebonden worden met één van twee andere rollen. Die situatie ontstaat als er twee bind acties zijn, elk met een ander object en hetzelfde indirecte object.
Gegeven r1 (leeg) en r2 en r3
	* a1 heeft r1 als indirect object en r2 als object (voorwaarde: r1 leeg, r2 beschikbaar)
	* a2 heeft r1 als indirect object en r1 als object (voorwaarde: r1 leeg, r3 beschikbaar)
	
Een ander voorbeeld is de verwisseling van rolbindingen. Gegeven r1 en r2 met bindingen.
	* a1 selecteert de binding van r1 als object (onvoorwaardelijk)
	* a2 maakt r1 leeg 
	* a3 kopieert r2 naar r1 (voorwaarde: r1 leeg, r2 niet)
	* a4 maakt r2 leeg
	* a4 kopieert het object van a1 naar r2 (voorwaarde: a1 heeft object, r2 leeg)
Het resultaat is ongedetermineerd.

De de volgende serie heeft een gedetermineerd resultaat. Geïndenteerde acties zijn genest en worden pas uitgevoerd als de omhullende is geïnstantieerd.
	* a1 selecteert de binding van r1 als object (onvoorwaardelijk)
		* a2 maakt r1 leeg (onvoorwaardelijk)
	* a3 selecteert de binding van r2 als object (onvoorwaardelijk)
		* a4 maakt r2 leeg (onvoorwaardelijk)
	* a5 kopieert het object van a3 r2 naar r1 (voorwaarde: a3 heeft object, r1 is leeg)
	* a6 kopieert het object van a1 naar r2 (voorwaarde: a1 heeft object, r2 is leeg)

Kortom: het is heel goed mogelijk om een verzameling basisacties te maken die een ongedetermineerde uitkomst heeft.
Het eerste verwisselvoorbeeld kunnen we lezen als een geordende serie assignments en dan is de uitkomst wel gedetermineerd. Ik vind dit een helderder notatie dan de tweede.
In plaats van een volgorde vast te leggen, kunnen we ook een (partiële) ordening afdwingen door sommige acties te nesten.

In principe kunnen we bij een verzameling acties met een gedetermineerde uitkomst, een volgorde kiezen die dezelfde uitkomst geeft. We kunnen dan de verzameling acties vervangen door een serie geordende assignments.


OVER HET CREEEREN VAN RESOURCES
1. Als we Perspectives beschrijven in termen van RDF(S), dan zien we dat Contexten, Rollen en Values de enige Resources zijn.
2. In RDF kan je geen Resources als zodanig aanmaken. Je kunt alleen beweringen over Resources doen.
3. Je kunt een Resource introduceren in een theorie door vast te leggen wat zijn type is.
4. In CRL kun je evenmin een Resource introduceren zonder er direct dingen over te zeggen. Je moet:
	a. een Context direct een type geven;
	b. een Rol direct een type geven èn een Context;
	c. een Waarde direct aan een Property binden, waarmee je hem tevens (indirect) typeert.
Dit zijn ondeelbare acties. Je kunt niet een context maken zonder type. Je kunt niet een Rol-instantie maken zonder hem in een context te plaatsen. Je kunt geen waarde maken zonder hem te binden aan een property.

OVER HET BENADEREN VAN RESOURCES
In een RDF theorie kun je elke resource als uitgangspunt nemen voor een Sparql query. 
In Perspectives kan dat niet. In de eerste plaats is elke query ingebed in een context of een rol. Hij heeft die context of rol ook als vertrekpunt. 
In theorie kun je een type als vertrekpunt nemen en zo alle instanties (van contexten of rollen) vinden. We ondersteunen dat in de praktijk niet (altijd). 
De relatie tussen een waarde en zijn type is indirect. In principe kun je alle properties (typen) vinden die een bepaald waarde-type hebben (hoewel het de vraag is of we dat in de praktijk ondersteunen). Daarmee vind je de bijbehorende roltypen. Dus, zouden we de relatie tussen typen en instanties perfect ondersteunen, dan kon je ook een query opstellen die alle voorkomens van een bepaalde waarde (bijvoorbeeld '2') vindt.

OVER BESCHIKBAARHEID EN ACTIES IN DE PURESCRIPT IMPLEMENTATIE
Ik heb nog geen mechanisme dat let op de beschikbaarheid van het object of indirect object van een actie. Evenmin let ik erop of een functionele rol of property leeg is, voordat ik eraan bind of een waarde geef.
Voor de botacties is dat wel van belang. Ik zou automatisch aan de conditie van de actie iets kunnen toevoegen waardoor er wel op gelet wordt.
Je kunt ook de modelleur er verantwoordelijk stellen. Er zullen best situaties zijn waarin een expliciete conditie helemaal niet nodig is (b.v. bij toekennen van een waarde aan een property van de binnen- of buitenrol; immers, de actie is ingebed in de context waar het om gaat en die heeft per constructie een binnen- en buitenrol).

OVER GENESTE ACTIES
Als ik de basisacties uitwerk als assignments, kan ik er geen acties in inbedden. Maar dat lijkt met niet nodig omdat ik met volgorde hetzelfde kan bereiken.
Ik kan wel toestaan dat acties in andere acties worden ingebed. Zodra een actie geïnstantieerd wordt, kan ik de botacties in die context dan opzetten. Het is wel de vraag of dat iets toevoegt op datgene wat je kunt uitdrukken in termen van assignments.

OVER VOOR DE GEBRUIKER BESCHIKBARE ACTIES
Cor heeft een punt: ook in Perspectives I rekende ik uit welke acties beschikbaar waren. Ik kan, analoog aan de manier waarop dat voor botacties gebeurt, per gebruiker-actie een Boolean query opzetten die aangeeft of die actie beschikbaar is. Bij een context kan ik dan een berekende rol maken met uitvoerbare acties.

OVER ACTIES MET OBJECT EN INDIRECT OBJECT MET HOGERE CARDINALITEIT
De assignment operatoren die ik heb, zijn gemaakt voor functionele argumenten.
Maar ik kan setProperty eenvoudig aanpassen zodat je meerdere waarden ineens kunt zetten.
Bovendien: het effect wordt verbonden met de indirect-object-query. Als die meerdere rollen oplevert, wordt aan de property van elk van hen een waarde toegekend.
Dit geldt voor alle effecten. Kortom, goede afhandeling van een relationeel object van een Actie is al ingebouwd - voor bots.
HELAAS, dit is niet correct. Ik kies in constructActionFunction de eerste rol als indirect object.
Ik zal bij implementatie van gebruiker-acties er goed op moeten letten dat dat ook gebeurt.

En indirect object? Dit kan op dezelfde manier, moet in de implementatie van Actions.constructActionFunction.

Tenslotte: ik heb nog geen syntax voor het creeeren van een Context of Resource. Evenmin heeft constructActionFunction daar gevallen voor.

MET COR BESPREKEN
1. De benoeming van object en indirect object bij de assignments.
	fills: object = wat je vult, indirect object = waarmee je vult
2. De cardinaliteit van object en indirect object.
3. De volgorde kwesties:
	* de modelleur moet zorgen voor een gedetermineerde uitkomst
	* ik kan zo'n model in principe omzetten naar een serie assignments.
4. Zijn basisacties zijn mijn assignments.
