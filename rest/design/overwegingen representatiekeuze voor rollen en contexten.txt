We hebben:
	- Context
	- Rol = RiC | ZR
		- RolInContext (RiC)
		- ZelfRol (ZR)
	- PropertyPerspectief
	- Property

Context heeft Rollen. Het algemene patroon is:
	- rolNaam: Context (1) -> Rol (n)

Context heeft een standaard property:
	- context_ZelfRol: Context (1) -> ZelfRol (1)

Rol heeft Properties. Het algemene patroon is:
	- propertyNaam: Rol (1) -> value (1 of n)
	waarin:
	value = Number | Boolean | String | Date

RolInContext heeft een standaard property:
	- rolbinding: RiC (1) -> Rol (1)

Rol heeft PropertyPerspectieven. Het algemene patroon is:
	- propertyPerspectiefNaam: Rol (1) -> PropertyPerspectief (n)

PropertyPerspectief heeft Properties. Het algemene patroon is:
	- propertyNaam: PropertyPerspectief (1) -> Property (n)

De eerste drie moeten beide kanten op overgestoken kunnen worden. Om die reden zijn ze dubbel gerepresenteerd. Omdat alle patronen 1:n zijn, kunnen we bij de n kant een backlink aanleggen.

De representatie wordt nu in essentie:

Context :: 
	{ context_ZelfRol :: ZelfRol
	...
	}

of:

data Context = Context ZelfRol Rollen

type Rollen = StrMap Rol

RolInContext :: 
	{ rolbinding :: Rol
	, context :: Context
	, propertyPerspectieven :: PropertyPerspectief
	...
	}

ZelfRol :: 
	{ context :: Context
	, propertyPerspectieven :: PropertyPerspectief
	... 
	}

of: 
data Rol = 
	RolInContext Context (StrMap Property) (StrMap PropertyPerspectief) Rol |
	ZelfRol Context (StrMap Property) (StrMap PropertyPerspectief)

data Property = Property ValueType IsFunctional IsInverseFunctional

data ValueType = PString | PBoolean | PNumber | PDate

type IsFunctional = Boolean

type IsInverseFunctional = Boolean

data PropertyPerspectief = PropertyPerspectief Rol (StrMap PropertyId)

type PropertyId = String


============================= REFLECTIE =============================
1. Alle vier de concepten zouden als records geïmplementeerd moeten worden, niet als ADT's. Reden: dan is het mogelijk om ingelezen Json met een foreign function direct witgewassen op te leveren (vier foreign functions die de juiste types leveren).
2. Sommige properties zijn verplicht. Voorbeelden zijn context_ZelfRol en property_Range. Deze zouden als aparte members van het record gemodelleerd kunnen worden. Dat heeft als voordeel dat ze getypeerd kunnen worden gerepresenteerd (dus b.v. isFunctional kan een Boolean value hebben). Dat kan niet, als ze als lid van de StrMap van Pproperties gemodelleerd worden. 
MAAR: we willen deze properties óók als Pproperties kunnen gebruiken. Dat betekent weer dat ze ongetypeerd, dus als strings, en bovendien in Maybe moeten worden opgeleverd... Dat doet het voordeel weer teniet.
Dus òfwel we maken verplichte properties een onderdeel van Perspect (maar let op: dan verdubbelt het aantal compositie operatoren) òfwel we maken in niet-property functies gebruik van de record structuur en daarnaast maken we er getters van. 
M.i. is het sop de kool niet waard. Dus...
3. ...dit betekent dat we alle vier gaan implementeren als een StrMap van properties.
4. Het blijft m.i. een goed idee om alle vier de concepten apart op te slaan in couchdb. Je zou kunnen overwegen om contexttypes als geheel op te slaan, omdat de kans groter lijkt dat je alle onderdelen nodig hebt. Maar dan moeten we in types verwijzingen naar rollen uitvoeren met een paar van contextId en RolId. Dat is onhandig.
Kortom: alle vier gescheiden opslaan.
Dat betekent dat onderlinge verwijzingen met een ID gaan. Het betekent óók dat er een index of indices moeten bestaan om verwijzingen te kunnen volgen.
5. Voor dependency tracking houden we de triple administratie. Reden: we muteren alleen basisfeiten.
6. De eindconclusie is dan dat de representatie nauwelijks zou veranderen. Er komt een oppervlakkige typering van Resources bij maar daar doen we nauwelijks iets mee. De type controle die Purescript toevoegt, stelt voor Perspect niets voor.

Lessen:
1. We kunnen in de huidige implementatie de Json direct witwassen (parseren hoeft niet, als we voldoende vertrouwen op de representatie). Dit is een (kleine) optimalisering.
2. 
