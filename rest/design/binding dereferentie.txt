Een RolInContext kan gevuld worden met een andere RIC of met een Context:
Verbalisant (Functioneel) gevuld door Persoon
Start (Functioneel) gevuld door Intake
In termen van CRL is de instantie van Start gevuld door de buitenrol van Intake. De context van die buitenrol is de instantie van Intake zelf.

Laat A een aangifte zijn. Dan verwacht de modelleur als resultaat van deze query:
	A ## Verbalisant ~> binding
de RolInContext die een instantie is van Persoon.
Ik vermoed dat hij als resultaat van deze query:
	A ## Start ~> binding
dan ook de Context verwacht die een instantie is van Intake en niet de buitenrol van die instantie. Hij heeft immers niet gespecificeerd dat Start gevuld wordt door de buitenrol van Intake. 
Maar als ik geen gevalsonderscheiding doe in de implementatie van 'binding' op RIC's die gevuld worden door RIC's en RIC's die gevuld worden door buitenrollen, levert de tweede query gewoon die buitenrol. Dus als je de context zelf wil, moet je dit doen:
	A ## Start ~> binding ~> context
Laat 'afgerond' een externe property zijn van Intake, dan vraag je die op met:
	A ## Start ~> binding ~> afgerond
Een property 'toegewezen' van de rol Start vraag je natuurlijk zo op:
	A ## Start ~> toegewezen
Een interne property 'aantekening' van Intake vraag je dan zo op:
	A ## Start ~> binding ~> context ~> aantekening
(merk op dat de binnenrol overgeslagen wordt)



Als we het eens over een andere boeg gooien? Stel dat je met de query
	A ## Verbalisant
direct de RIC krijgt die de Persoon representeert. De binding dus van de rol Verbalisant. 
Als je dus schrijft:
	A ## Verbalisant ~> voornaam
krijg je direct de voornaam van de persoon die gebonden is aan de verbalisant. Met de operator 'binding' kun je nog steeds de binding van een rol opvragen:
	A ## Verbalisant ~> binding
levert je dan de binding van Persoon, laten we zeggen dat dat de Gebruiker is.

Wil je de rol zelf, b.v. omdat je een property van de rol wil, dan schrijf je dit:
	A ## rol Verbalisant ~> beoordeling
(laat beoordeling even een rapportcijfer zijn voor zijn prestatie bij deze aangifte)
(dus "rol Verbalisant binding" is hetzelfde als alleen "Verbalisant").

Dit geldt voor een RIC gebonden aan een RIC maar ook voor een RIC gebonden aan een Context, waarbij we dan meteen doorprikken naar de achterliggende context.

Dus voor gebonden contexten, krijg je bij:
	A ## Start 
direct de context die de Intake representeert. Je slaat hier dus twee rollen over. Dit maakt het mogelijk om te schrijven:
	A ## Start ~> Uitvoerder
(waar Uitvoerder een rol van Intake is).

Met:
	A ## rol Start ~> toegewezen
krijg je echter, net als bij Verbalisant, (een property van) de rol in context. Een property van de buitenrol vraag je dan zo op:
	A ## extern Start ~> afgerond
Dus de werking van de operator 'extern' is dat automatisch de binding van de rol in context wordt opgehaald.

Dit past in de compositionele aanpak van queries, waarbij ik van links naar rechts de query termen kan vertalen in operators. Ik kan dit implementeren met behulp van reflectie op het type van de mogelijke vulling van een rol. Is dat een RIC, dan pak ik de binding van de rol; is het een Context, dan pak ik de binding van de binding van de rol.

Merk op dat "A ## Start extern afgerond" niet werkt, want als je van links naar rechts loopt heb je de Context al te pakken voor je weet dat je alleen zijn buitenrol nodig had. Uiteraard kunnen we andere namen voor de operatoren kiezen (persoonlijk zou ik iets met de betekenis van proxy beter vinden dan extern).


Of nog weer anders.

	A ## Verbalisant ~> beoordeling

werkt klassiek, dus je vraagt hier de property van de rol Verbalisant. Met 

	A ## Verbalisant ~> binding ~> voornaam

vraag je de property 'voornaam' van de instantie van Persoon die de rol Verbalisant vult.

En met
	
	A ## Start ~> binding ~> afgerond
	
vraag je de property 'afgerond' van de buitenrol van Intake op.
Maar met:

	A ## Start ~> gebondenContext ~> Uitvoerder

pak je ineens de rol Uitvoerder van de instantie van Intake. Oftewel, gebondenContext == binding ~> context.



Nog een syntactisch alternatief:

	A ## Start ~> toegewezen
	
	A ## Start ~~> afgerond
	
	A ## Start ~~~> Uitvoerder
	
En:

	A ## Verbalisant ~> beoordeling
	
	A ## Verbalisant ~~> voornaam
	
	A ## Verbalisant ~~~> X

De laatste expressie levert de rol of property X van de context van de binding van Verbalisant. 

~~> == ~> binding
~~~> == ~> binding ~> context


TYPE, DISPLAYNAME, CONTEXT, BINDING
Deze gegevens zijn niet als rollen of properties van contexten of rollen gerepresenteerd, maar als directe members van de basisrepresentatie. Hoe kun je queries opstellen die deze gegevens opvragen?

Eén antwoord is: er zijn specifieke operatoren voor:
	* contextType (PerspectContext.pspType)
	* label (PerspectContext.displayName)
	* rolType (PerspectRol.pspType)
	* rolContext (PerspectRol.context)
	* binding (PerspectRol.binding)

Kunnen deze gegevens voorkomen in een View? Alleen label, want die heeft een SimpleValue. De anderen hebben een Rol- of Context waarde.

Wat doe je met een view? Op enig moment haal je de properties die genoemd zijn in de view, op bij een rol.
Haal je dan psp:label op, dan moet je de operator label gebruiken. Bij alle andere properties genereer je een getter.

BASISACTIE
Een BasisActie waarmee je een property verandert, heeft nodig:
	- de rol
	- de naam van de property
	- de waarde van de property (als het werkwoord vervang of voegtoe is)
	- het werkwoord: vervang, voegtoe, verwijder

Als de propertynaam psp:label is, dan moet je een andere wijziging uitvoeren dan bij alle andere property namen.

GELIJKTIJDIGE WIJZIGING VAN PROPERTIES EN ROLLEN
Als de gebruiker de tekst van een commentaar aanpast, kan het aantalRegels daarvan heel wel tegelijk veranderen. 
Als de gebruiker een diagram object verplaatst, zal hij meestal de x- en y-coordinaat tegelijk veranderen.
Dit gaat om de properties van één rol.

Maar als de gebruiker een commentaar (of ander tekstelement) verplaatst naar een andere positie tussen zijn siblings, verandert de positie van meerdere (minstens twee) siblings tegelijk.

Representeren we dat met aparte delta's/basisacties? Minstens wil je dat ze in één transactie doorgevoerd worden.

Hoe beschrijf je zulke acties, in ARC? 

TRANSACTIES
Een transactie bestaat uit auteur en timeStamp en een collectie deltas. 
Een Delta identificeert een context of rol, een rolnaam of een propertynaam, een operatie en optioneel een waarde.