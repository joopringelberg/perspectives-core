HOE REPRESENTEREN WE RESOURCES?

1. Een Resource is een Id en een StrMap naar Array String.
2. Een Resource wordt bij representeren opgeslagen in een locatie.
3. We moeten vanuit een Resource zijn locatie kunnen vinden (suggestie: verborgen pointer)
4. Het data type PropertyValue heeft twee constructors: Resource en Literal.
5. Een Locatie met een Resource erin is via property functies verbonden met Locaties met Array PropertyValue.
6. Een property functie is: Resource -> Property -> Array PropertyValue.
  OF:
  Property -> (Resource -> Array PropertyValue).
  In dit geval hoeft de eerste stap niet gelift te worden over Locatie.
7. Voor de keuze tussen Resource en Literal moeten we dus de range van de Property weten. Slaan we die op in Property,
of kijken we dat na met een property functie?
8. Merk op dat we dus alles in de context doen van multi-values. Hoe werkt dat b.v. met filteren? De boolean property waarde
van een Resource waar je op selecteert, is dus opgeslagen in een Locatie, in een Array en is een Literal. Je filtert een Array van
Resources in een Locatie. De filter functie liften we over Locatie, dus die zijn we kwijt. Dan heb je een filter over Array Resource
met een filterfunctie Resource -> Bool. Maar de property functie geeft je Resource -> Array Literal. In do-notatie over Array:
let propVal = propertyfun resource
do
b <- propVal
if b Just resource else Nothing
Maar dat is veel te verboos. Je weet natuurlijk als schrijver dat propertyfun functioneel is. Dus dan doe je:
head propertyfun resource
Maar nu heb je een Literal Boolean... dus je moet nog liften!
Wat een gedoe.

Als we nu gewoon functies maken voor de verschillende propertywaarden?

Functionele property getters:
getResource :: PropertyName -> Resource -> Resource
getBoolean :: PropertyName -> Resource -> Boolean
getDate :: PropertyName -> Resource -> Date
getNumber :: PropertyName -> Resource -> Number
getString :: PropertyName -> Resource -> String

Relationele property getters:
getResources :: PropertyName -> Resource -> Array Resource
getDates :: PropertyName -> Resource -> Array Date
getNumbers :: PropertyName -> Resource -> Array Number
getStrings :: propertyName -> Resource -> Array String

Je moet dus bij de keuze van een van bovenstaande functies rekening houden met het type en de cardinaliteit van de property.
We moeten ook liften over locatie:

(getNumber 'per:leeftijd') <$> locWithResource

Maar een locatie kan ook een Array van Resources bevatten.

De functionele properties pas je dan toe met map (na liften over locatie):

(map $ getNumber 'per:leeftijd') <$> locWithResourceArray

De relationele properties pas je toe met bind op een Locatie met Array:

(flip bind $ (getResources 'per:kind')) <$> locWithResourceArray

Maar met map op een Locatie met Resource:

(map $ getNumbers 'per:leeftijd') <$> locWithResource

getFunctionalProperty :: (Resource -> a) -> Location Resource -> Location a
getFunctionalProperty getter l = (map $ getter) <$> l

getRelationalProperty :: (Resource -> Array a) -> Location Resource -> Location Array a
getRelationalProperty getter l =

getRelationalProperty' :: (Resource -> Array a) -> Location Array Resource -> Location Array a
getRelationalProperty' getter l =


En dan:

getFunctionalProperty (getNumber 'per:leeftijd') locWithResourceArray

En met een beetje suikersyntax:

(getNumber 'per:leeftijd') ~> locWithResourceArray

Waarbij we voor getRelationalProperty een ander kleurtje gebruiken:

(getResources 'per:kind') ~~> locWithResourceArray

En dan:

(getNumber 'per:leeftijd') ~> (getResources 'per:kind') ~~> locWithResourceArray

Functional properties:
Range Resource
Range Boolean
Range Date
Range Number
Range String
Non-functional properties:
Range (Array Resource)
Range (Array Date)
Range (Array Number)
Range (Array String)

Domain Resource
Domain (Array Resource)

Als je alleen let op cardinaliteit:

a a
a (Array a)
(Array a) a
(Array a) (Array a)

Singleton Singleton
Singleton Sequence
Sequence Singleton
Sequence Sequence

getProperty :: Location -> Location
- kijk of je een Array aantreft in de eerste Location.
- kijk of de property functioneel is: fprop :: resource -> (Resource | Literal), of relationeel:
  rprop :: Resource -> ()(Array Resource) | (Array Literal))
  Literal = Boolean | Number | String | Date
  Resource = { id :: String, properties :: Map}

  isFunctional :: Resource -> Boolean
  isFunctional r = r => hasType( r, 'owl:FunctionalProperty')

  hasType :: Resource -> String -> Boolean
  hasType r t = b where (Location b) = hasElement <$> locate t <*> getProperty 'rdf:type' r

  hasType :: Resource -> String -> Boolean
  hasType = (r, t) => hasElement( getRes(t))( getType(r))

  getRes :: String -> Resource
  getRes = compose( unloc, locate)

  getType :: Resource -> Array Resource
  getType = compose( unloc, getProperty('rdf:type'))

  hasElement :: a -> Array a -> Boolean

ALS l1 een Array a bevat,
  ALS p is functioneel DAN (map p a)
  ANDERS (bind p a)
ANDERS (p a)

Als je een andere functie lift moet je zelf opletten op wat er in de locaties zit die de argumenten verschaffen.
D.w.z. als je add1 wil liften over l1, moet l1 wel een integer bevatten. Anders schrijf je foute code.


type Domain = Location
type Range = Location
Connection Domain Resource Range Resource
Connection Domain (Array Resource) Range Resource

Maak elk van hen een instantie van een type class. De functie:

getProperty :: PropertyName -> Location a -> Location b


SomeThing Resource Resource
SomeThing Resource Boolean
SomeThing (Array Resource) Boolean
etc.
class SomeThing a b where
  getIt :: PropertyName -> Location a -> Location b

instance someThingRR :: SomeThing Resource Resource where
  getIt pn l1 = doMagic pn l1
