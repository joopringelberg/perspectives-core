WAT IS DE CENTRALE REPRESENTATIE?

Need to have:
1. Het moet als Json te zijn serialiseren, met behoud van structuur.
2. Mutaties van basisfeiten moeten er op kunnen worden uitgevoerd.
3. We moeten er tekst uit kunnen genereren.
4. We moeten het uit tekst kunnen genereren.
5. We moeten de noodzakelijke mutaties af kunnen leiden uit opeenvolgende versies van de representatie (of van json)

In schema:

text	->		REPRESENTATIE		-> text
				/\			/\
				|			|
				|			|
				\/			\/
				json		mutaties basisfeiten

Nice to have:
1. Enige flexibiliteit tussen text en representatie.
2. Buitenrollen kunnen worden geladen zonder de context.

KWESTIES
1. Bij assignment van context properties: bepaal of het gaat om een property van de binnen- of buitenrol.
Uit de representatie kun je slechts afleiden wat de propertynaam en (nieuwe) propertywaarde is. Modelreflectie moet duidelijk maken of het om een private of publieke property gaat.
Merk op dat het type van de context nog niet beschikbaar of volledig hoeft te zijn! In dat geval kun je de tekst dus wel parseren, maar niet verder interpreteren (naar json of mutaties).
Eventueel zou je privaat en publiek in instanties syntactisch van elkaar kunnen onderscheiden. Bijvoorbeeld zo:

	:Aangifte :aangifte1
		:Aangever => :Jansen
			:betrouwbaarheid = 10
		(:status = "voltooid")
		:urgentie = 5

Hier is :status een private property, :urgentie een publieke.

2. Als in de representatie de binnen- en buitenrol niet expliciet gemodelleerd worden, dan is het niet mogelijk om de buitenrol op te halen zonder de context op te halen. Terwijl dat wel een mooie manier is om zuinig grote aantallen contexten in te laden.

Stel dat we een context parseren als een pair van context en buitenrol? De binnenrol kan een structureel onderdeel zijn van de context. Dus zoiets:

	{
		context: 
			{
				id: "xxx"
				,binnenRol: { binding: ["xxx-buitenRol"] ...}
				,buitenRol: "xxx-buitenRol"
				...
			}
		buitenRol:
			{
				id: "xxx-buitenRol"
				...
			}
	}

Andere rollen komen ook in deze structuur (zie hieronder). Het wordt een StrMap van Context en Rol. Om dat voor elkaar te krijgen, moeten beiden onderdeel zijn van dezelfde ADT. We noemen dit abstracte datatype een "ContextCollection".

In couch breken we deze delen los en slaan ze apart op. Als je een context gaat editen, haal je ook zijn buitenRol op. Als je een BuitenRol gaat editen, hoef je niet zijn Context op te halen.

3. Hoe representeren we property- en rolassignments? Momenteel (in de huidige ADT) zijn ze als Lists gerepresenteerd. Dat is onhandig voor het ophalen van een property tbv een query. Een StrMap zou beter zijn. Kan een StrMap de target zijn van de parser?
Ja, natuurlijk. In de parser 'context' kan ik b.v. de lijst van properties omzetten in een StrMap en dan onderdeel maken van Context.

In combinatie met het idee bij (2) betekent dat, dat de private properties in de binnenRol terechtkomen - die dus een StrMap wordt van Array String. De public properties komen in de buitenRol van de collectie terecht.

4. Rollen met properties in een context.
De huidige representatie slaat een lijst van RolAssignmentWithPropertyAssignments op bij de context. Maar dit zijn natuurlijk zelfstandige rollen. Die zouden we dus óók op kunnen nemen in de compiler target op hetzelfde niveau als context en buitenRol. De target wordt daarmee een strMap van items die geïndexeerd zijn met hun id en apart in Couch opgeslagen worden. 
Bij een nieuwe parsering wordt altijd een hele context opnieuw ontleed. Je kunt dan per onderdeel van de gegenereerde StrMap kijken of er wijzigingen zijn. 

5. Wild idee: we zouden contexten met hun rollen als een enkel document kunnen opslaan in couch. Het ophalen van een Rol wordt daarmee iets anders dan het ophalen van een context. Nadeel: je moet met een context alle rollen ophalen. Voordeel: minder netwerk overhead om alle rollen van een context op te halen.

6. Overigens: als je b.v. een Domein edit, hoef je helemaal niet direct alle contexten en rollen op te halen. Je zou de contexten 'ingeklapt' kunnen tonen. Pas als je een context expandeert, worden de rollen opgehaald. Of als je een rol expandeert...
Je kunt zelfs de naam van een context intikken en die vervolgens laten expanderen!
Merk op dat de ContextCollection niet volledig hoeft te zijn als je hem bewerkt in de editor. 
Een onderdeel verwijderen kan dus alleen met een delta: twee opeenvolgende versies van de ContextCollection waarin dat onderdeel eerst wel, vervolgens niet voorkomt.

7. De consequentie van deze representatie is dat in property.purs de simpele functie 'getObjectsGetter' gesplitst moet worden in:
	- getPrivatePropertyGetter
	- getPublicPropertyGetter
	- getRolPropertyGetter
	- getRolObjectsGetter

constructTripleGetter moeten we dus ook splitsen in deze vier categorieën. Een property als rdfs:label bijvoorbeeld, wordt gesplitst in twee functies: contextLabel en rolLabel. De eerste wordt gemaakt obv getPublicPropertyGetter en de tweede obv getRolPropertyGetter. Het zijn echter wel allemaal NamedTripleGetters, zodat compositie en combinatie werkt.

8. Er komen speciale properties:
	- id
	- pspType
	- binding
	en eventueel:
	- buitenRol
	- binnenRol
Zij grijpen rechtstreeks aan op de basisrepresentatie.

REPRESENTATIE VAN EEN CONTEXT-TYPE
Een voorbeeld:

	DEF :ContextType :Aangifte

Dit definieert een type context, namelijk :Aangifte. Deze moeten we representeren als een Context.
PerspectContext is een record met:

	{ id :: ID
	, pspType :: ID
	, binnenRol :: PerspectRol
	, buitenRol :: ID
	, rollen :: StrMap (Array ID)

Substitutie:

	{ id: ":Aangifte"
	, pspType: ":ContextType"
	, binnenRol: 
		{ id: ":Aangifte_BinnenRol"
		, pspType: [:BinnenRol]
		, properties:
			{ binding: [":Aangifte_BuitenRol"]
			} 
		}
	, buitenRol: [":Aangifte_BuitenRol"]
	, rollen: {}
	}

REPRESENTATIE VAN EEN ROL-TYPE VAN EEN CONTEXT-TYPE
De buitenrol van een bepaald typen contexten heeft een aantal properties dat beschreven moet worden. De beschrijving is het rol-type. We beschrijven zo'n rol-type met een Context, waarvan de rollen de properties representeren. Hieronder werken we het voorbeeld uit van een property van de buitenrol van :Aangifte.


REPRESENTATIE VAN EEN PUBLIC PROPERTY-TYPE VAN EEN CONTEXT-TYPE
Een voorbeeld:

	DEF :ContextType :Aangifte
		public :urgentie
			:isFunctional = true
			:isVerplicht = true
			:range = Number

Dit definieert een public property :urgentie. Deze moeten we representeren als een RolInContext (zie "tests syntax"). Hoe en waarvan?
PerspectRol is een record met:

	{ id :: ID
    , pspType :: ID
    , binding :: Maybe ID
    , properties :: StrMap (Array String)
    }

Substitutie:

	{ id: ":urgentie"
	, pspType: [":PropertyType"]
	, properties: 
		{ ":isFunctional": ["true"]
		, "isVerplicht": [ "true"]
		, ":range": ["Number"]
	}
	
Deze Rol is een rol van de context die de buitenrol representeert van de context waar de property bij hoort. Die context is:

	{ id: ":BuitenRolTypeVanAangifte"
	, psptype: [":BuitenRolType"]
	, binnenRol: {...}
	, buitenRol: ["BuitenRolBijAangifte_BuitenRol"]
	, rollen:
		{ ":urgentie": [":Aangifte_urgentie"]
		}
	}

En de rol is: 

	{ id: ":Aangifte_urgentie"
	, pspType: [":PropertyType"]
	, properties: 
		{ ":isFunctional": ["true"]
		, "isVerplicht": [ "true"]
		, ":range": ["Number"]
	}

Dus als je wilt weten of de property :urgentie van een instantie :aangifte moet worden ingevuld, dan voer je de volgende query uit:
	
	:Aangifte ## 


APARTE ADTS VOOR CONTEXTTYPE EN ROLTYPE?
1. Hoe gaan we een diagram maken waarin types als contexten worden getoond?
Een contexttype heeft dan een binnen- en een buitenrol. Als je die opent in hun roldiagram, zie je de property-typen.
Maar eigenlijk worodt b.v. de binnenrol met een context gerepresenteerd. Je opent dus een context. De property-typen zijn daar rollen en die wil je verbeeld zien met het property-symbool, een horizontale balk.
Terugkomend op het contexttype: de binnenrol die je ziet, is niet de binnenrol van de context die het context-type representeert. Het is de rol die gevuld is met de zelfrol van de context die het *type* van die binnenrol representeert.

REPRESENTATIE VAN EEN PROPERTYPERSPECTIEF
Een Property-perspectief is een collectie van properties, die hoort bij een bepaalde rol. Een Property-perspectief wordt niet geïnstantieerd. We hebben dus een representatie nodig met elementen die naar rollen kunnen wijzen (want properties worden beschreven met rollen; een property-type is een rol).
Een goede kandidaat voor een Property-perspectief-beschrijving is daarom een Context. Elke Rol van de context is gevuld met een Rol uit de Context waarmee we een Rol beschrijven.
Een Property-perspectief hoort ook bij een Rol. We gebruiken daarom ook rollen in de context waarmee we een Rol beschrijven, om de bijbehorende Property-perspectieven te binden.
We krijgen daarom in de context waarmee we een Rol-type representeren, twee soorten rollen: 
	* rollen die properties beschrijven (zonder binding)
	* rollen die Property-perspectieven beschrijven, d.w.z. hun binding is een context die een PP beschrijft.
De rollen van een Perspectief hebben kanonieke namen, namelijk het getal dat hun positie in het perspectief aangeeft.