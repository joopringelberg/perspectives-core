BinnenRol en BuitenRol

psp:Context definieert twee rollen in context:
	* binnenRolBeschrijving
	* buitenRolBeschrijving

Deze twee zijn verplicht voor elke instantie van psp:Context - dus óók voor psp:Context zelf.
Maar in de definitie van psp:Context vind je geen rol $binnenRolBeschrijving.
Wel is er een prototype (en er is speciale syntax voor de rol $prototype!) en dat prototype heeft een rol $binnenRolBeschrijving.

Overigens, als we de binnenRol van psp:Context in zijn eigen definitie op zouden nemen, moesten we hem wel een naam geven die de rol(instantie) onderscheidt van de rol-definitie!	
psp:Context psp:Context
	prototype psp:ContextPrototype
	$rolInContext =>
		psp:Rol $binnenRol	-- rol definitie 
			extern $isFunctioneel = true
			extern $isVerplicht = true
			$mogelijkeBinding => psp:Rol
	$binnenRol =>
		psp:Rol $binnenRolVanContext -- rol instantie, moet andere naam hebben.
			extern $isFunctioneel = true
			$mogelijkeBinding => psp:Rol

Tenslotte: er is geen enkele reden om 'binnenRolBeschrijving' aan te houden. "Beschrijving" kan eraf (maar heeft code consequenties).

TODO:
Verander 'binnenRolBeschrijving' in 'binnenRol' (en idem voor buitenRol). 
Dit heeft code consequenties.
Procedure:
1. Pas het model aan in tekst.
2. Gebruik oude code (die gebruikt oude JSON) om het nieuwe model op te slaan als JSON.
3. Verander de code.

SCHADUWING VAN PROTOYPES DOOR LOKALE ROLLEN
De functie getter (searchRolLocallyAndInPrototypeHierarchy "binnenRolBeschrijving") vindt, toegepast op psp:Context, de rol psp:ContextPrototype$binnenRolBeschrijving. 
Een lokaal vastgelegde rol heeft voorrang boven een rol van een prototype.


PROTOTYPE HIERARCHY HEEFT ÉÉN TYPE
Een prototype moet natuurlijk hetzelfde type hebben als de context waarin hij wordt gebruikt. Dus de rollen van het prototype zitten in dezelfde namespace als de rollen van de context. De hele prototype-hierarchie bestaat dus uit contexten van hetzelfde type.

searchRolLocallyAndInPrototypeHierarchy hoeft dus maar één keer een gekwalificeerde naam vast te stellen.


LOKALE AANVULLING VAN ROL IN PROTOTYPE
Beschouwen we een property van de binnenRol.
1. Als de binnenRol niet lokaal is gedefinieerd, wordt de property bij het prototype gevonden.
2. Als de binnenRol óók lokaal is gedefinieerd, maar niet de property draagt, wordt die dan wèl gevonden bij (rol van) het prototype?

je moet dan de prototype hierarchie doorzoeken met een getter die éérst de rol vindt en dàn de property. Als die op de lokaal gerepresenteerde rol de property niet vindt, faalt hij. Daarna wordt het prototype doorzocht. Dus: ja.

searchPropertyOfRol :: forall c e. ContextType c => RolDef -> PropertyDef -> c -> Val
searchPropertyOfRol r p = searchLocallyAndInPrototypeHierarchy (getRol r) /-/ (getProperty p)

of zo, waarbij we ook in de roltelescoop kijken: 

searchPropertyOfRol r p = searchLocallyAndInPrototypeHierarchy (getRol r) /-/ (searchQualifiedProperty p)

maar dan is zoeken naar een ongekwalificeerde property logischer:

searchPropertyOfRol r p = searchLocallyAndInPrototypeHierarchy (getRol r) /-/ (searchUnQualifiedProperty p)
