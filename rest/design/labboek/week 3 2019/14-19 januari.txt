LABBOEK WEEK 14-19 JANUARI

TODO
7. Maak het mogelijk om modellen in te lezen.

8. Werk de modellering van TrustedCluster en RelayServer uit (zie modellering TrustedCluster).

9. Drag and Drop.

10. AddRol is een onderdeel van de API. Breid de API uit met de andere setters.

11. Voeg een drempel voor Transactie-executie toe (verwerk slechts transacties die minimaal een bepaalde leeftijd hebben).

12. Ik vind geen heldere beschrijving van de rollen op couchdb. Voor de RelayServer is dat goed uitgewerkt, maar niet beschreven. Is het voor een lokale couchdb hetzelfde, of niet? Voorlopig is het niet zo belangrijk omdat we alles via de RelayServer doen.

13. Uitzoeken: kan ik betalen voor de Repository opnemen in InPlace? Per slot van rekening bestaat InPlace uit Html pagina's en kunnen we een betaalservice vanuit zo'n pagina ontsluiten. Je navigeert echter gewoonlijk naar een andere pagina zodra je gaat betalen. De vraag is hoe of dat loopt. Vermoedelijk moet er een geautoriseerde server tussen de app en de betaalserver zitten.

14. Voeg command line parameters toe aan de electron app, zodat ik kan spelen met de frequentie van het verwerken van de TripleQueue en Transacties.

15. Modelleer de context "Model", met de rollen *gemodelleerdeContext* en *onderscheidenContext*. Kan een onderdeel zijn van model:Perspectives. 


IN UITVOERING
Modellen inlezen.

DONE
1. Gelezen:
	* minimale plek voor crowdfunding.
	* modellering TrustedCluster
	* Ontwerp van uitbreiding van de API met mutaties.
	* modellering relayserver. Dit kan ik voorlopig negeren. Het is een model in pseudo-Arc en inmiddels heb ik een andere benadering voor het abonneren op de RelayServer, namelijk via een Plek met een handgemaakt scherm.
	* Herorientatie op Sync. Dit gaat vooral over de RelayServer als zelfstandig proces/programma.

2. Beschrijf in een Word document het proces/mechanisme waarmee een geserialiseerde context van buiten wordt opgenomen in de Bubble. Waarom hebben we dit nodig? Denk aan uitnodigen en aan websites waar je een dienst of product wilt afnemen, zoals de RelayServer.

3. Een Model moet aangeven wat *onderscheiden plekken* zijn die je typisch aanmaakt om met het model te gaan starten. Beschrijf dit.

4. Beschrijf in een Word document hoe de geïndexeerde identifiers tijdens sync vervangen worden door guids (dit is in de tekst "Context met uitnodiging" opgenomen).

5. Maak een functie om meerdere contexten ineens in te lezen (zie Zie BasicConstructors en ContextSerialization in PerspectivesApiTypes).

6. modifyTriple etc. Is dat klaar? Ja.


==================================================================================================================
MODELLEN INLEZEN

Er is een property die ik moet vullen met de sourcetekst van een model en dan zijn er computed properties voor de syntactische- en semantische fouten. Welke properties gaat het om?

	* de interne contextproperty sourceText
	* parserMessages: een array van strings (berekend door: parserMessagesM)
	* de boolean syntacticState (berekend door: syntacticStateM)
	* typeCheckerMessages: een array van strings (berekend door: typeCheckerMessagesM)
	* de boolean semanticState (berekend door: semanticStateM)

Er lijkt geen idee uitgewerkt te zijn in de core waardoor een geldig model direct opgeslagen wordt. Klopt dat? Er is iets met een aantal keren opslaan, dacht ik.

In de Halogen interface kon ik modellen opslaan.

Zie: "crl editing".

Ingrediënten:
	- timestamp van het zetten van de property sourceText;
	- timestamp van het opslaan in couchdb;
	- berekende property: 'opslag is nodig' is true als de sourceText recenter is dan de opslag.

Hoofdlijnen:
1. Abonneer een functie op een eindpunt van het dependency netwerk, analoog aan de manier waarop de API dat doet voor een getter.
2. Deze functie ontvangt de waarde van een (boolean) property. Al naar gelang die waarde slaat hij het bestand op in couchdb (welk bestand? Hoe weet deze functie waar het over gaat???) en zet zelf een timestamp.
3. De query die op dat punt eindigt, vergelijkt de timestamps and maakt een conjunctie met de geldigheidsbooleans.
4. Het abonnement wordt genomen op het moment dat *iets* aan de context verandert die deze tekst representeert.
5. De bot zou een rol bij de context kunnen zijn. Zijn acties vinden we dan door naar zijn subjectRollen te kijken.
6. We moeten dan Actie uitbreiden met een conditie.
7. Sowieso hebben we nog geen notie van het effect van een Actie. Acties gebruik ik tot nog toe alleen om te bepalen wie wat mag zien.

Er is syntax, in query.crl, voor assignment. We kunnen Actie dus uitbreiden met een rol 'effect' die gevuld wordt door (de buitenrol van) een context q:assignToRol of q:assignToProperty. Maar, er is in de core nog geen functionaliteit die ook daadwerkelijk iets doet met zo'n beschreven zij-effect (zoals dat al wel bestaat voor getters, in Perspectives.QueryCompiler).

[Hier moet het mechanisme dat we in Perspectives I hadden, opnieuw worden gemaakt: bij aanmaak van een Actie-instantie moet het zij-effect van die Actie worden uitgevoerd. Dus dan moet de beschrijving, een instantie van q.assignToProperty, door een functie omgezet worden in de daadwerkelijke aanroep van setProperty. Uiteraard kan de rol 'effect' meerdere bindingen hebben.
Maar: dit is voor het opslaan van modellen niet zo relevant. Dat is een ander type zij-effect dan assignment (de timestamp kan de functie gewoon rechtstreeks zetten).]

Oftewel, we moeten in de rol 'effect' óók een context accepteren die een speciale, effectvolle functie beschrijft (c.q. het bestand opslaat in couchdb en de timestamp zet). Dit zijn speciale functies, waarvan de implementatie in de core opgenomen is.

De parameters van de speciale effectvolle functie zouden we kunnen beschrijven in termen van queries die vertrekken van de context waar de Actie bijhoort. In dit geval is dat de 'text' context en de relevante properties daarvan zijn:
	* sourceText
	* modelName (nog niet beschreven; klopt dit wel?)
	* de computed property 'mustBePersisted'
De laatste parameter is anders dan de anderen omdat het de enige trigger is: alleen als deze waarde verandert, moet de effectvolle functie uitgevoerd worden. Bij bot-acties is er altijd een trigger en dat is natuurlijk altijd een boolean functie. Het is niet nodig om die in de beschrijving van de speciale effectvolle functie op te nemen. Immers, hij is al beschreven als de conditie van de bot-actie. Per conventie maken we daar de eerste parameter van de purescript functie van.

En tenslotte nemen we in Actie ook de rol 'conditie' op, die gevuld wordt met een query met boolean resultaat.

Er is ook syntax, in query.crl, voor n-ary combinators: q:nAryCombinator. Hiermee kan ik een 'and' beschrijven. Ik moet Perspectives.QueryCompiler nog wel uitbreiden voor de logische combinatoren.

Alternatief:
1. We introduceren een soort property-met-zij-effect. Zodra je die property een waarde geeft, wordt ook een functie uitgevoerd die het zij-effect realiseert.
2. In dit geval zou de property tekst-in-de-database zijn en het zij-effect is dat de waarde ervan opgeslagen wordt in couchdb.
3. Met zo'n property kunnen we de controle client-side houden: we kunnen het veranderen van de property onder een 'sla-op' button stoppen, of we kunnen een 'deamon' opzetten die de timestamps etc. vergelijkt.
