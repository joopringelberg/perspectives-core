TODO

1. Refactor aan de hand van de compositie operator voor ObjectsGetter. MIN OF MEER KLAAR

2. Lees na hoe rollen en properties ophalen met behulp van Aspecten werkt. Dat is uitgewerkt in getRolUsingAspects en booleanPropertyGetter. Probeer na te gaan waar dat nog meer invloed zal hebben.
	- hernoem booleanPropertyGetter
	
3. Het lijkt me dat er patronen van gebruik zijn op het niveau van de types, die een variant zijn op patronen van gebruik op het niveau van de instanties. 
	- Probeer die in kaart te brengen
	- Probeer met naamgeving voor functies helderheid te verschaffen
	- Annoteer functies op beide niveaus met Perspective types.
	MIN OF MEER KLAAR

4. Breid de TypeDefChecker uit voor Acties: objectRol en subjectRol.
5. Maak functies voor intellisense/de dialoog met de bot.
6. Een ander patroon: we hebben soms dezelfde TripleGetters als ObjectsGetters. Neem mogelijkeBinding, die uitgewerkt is als TripleGetter maar ook als ObjectsGetter zou kunnen worden uitgewerkt.
7. Heeft het zin om het Alt patroon voor TripleGetters te maken?

8. Het lijkt erop dat closure maar twee stappen diep gaat, voor aspectDefClosure. Dit is een puzzel.


MEMORISEREN: VAN GETTERS NAAR COMPOSITIE-OPERATOREN
In plaats van memoriserende getters te maken (de TripleGetters) zou ik ook (compositie) operatoren kunnen maken die (al dan niet) memoriseren.

1. ObjectsGetters geven een Array String terug. Voor memoriseren heb je triples nodig. Wat geven memoriserende ObjectGetters voor resultaat? Kunnen ze Array String blijven teruggeven?

2. Dit zijn de voorgestelde use cases van memoriseren van ObjectsGetters:
	a. als we een (al dan niet samengestelde) ObjectsGetter memoriserend willen toepassen. Dit zou een nieuwe operator worden (een soort van functionCall);
	b. als we de onderdelen van een compositie willen memoriseren;
	c. in de (andere) combinatoren;
	d. bij het runnen van een query, om de startpositie in een queryvariabele op te slaan.
	e. bij het uitvoeren van een effect, zodat het opnieuw uitgevoerd wordt als de supports wijzigen.

3. Waar vindt het memoriseren nu plaats?

MEMORISEREN: HUIDIGE SITUATIE
Dit zijn de memoriserings-operatoren (de API van TripleAdministration) en de plekken waar gememoriseerd wordt:
	- memorize
		- QueryCombinators: closure, closure', filter, concat, intersect, notEmpty
		- TripleGetterComposition: composeTripleGetters, composeLazy
	- registerTriple
		- QueryEffect: addEffectToQuery
	- addToTripleIndex
		- RunMonadPerspectivesQuery: runMonadPerspectivesQuery, 
		- TripleGetterConstructors: constructTripleGetterFromEffectExpression
Hierbij zijn registerTriple en addToTripleIndex functioneel equivalent (maar de eerste neemt een triple en de tweede de losse onderdelen als argument).

DRIE FACETTEN
1. Een ObjectGetter moet een naam hebben, want:
	- dan kunnen we hem bij update opnieuw uitvoeren;
	- dan kunnen we composities een samengestelde naam geven.
2. We moeten dependencies en supports opslaan, want
	- de dependencies hebben we nodig om een assignment door te voeren in afhankelijke queries;
	- de supports hebben we nodig om de dependencies te herberekenen na een assignment.
3. We moeten het resultaat opslaan, want
	- anders moeten we telkens herberekenen.

MOETEN WE TRIPLES TERUGGEVEN OM DEPENDENCY TRACKING TE KUNNEN DOEN?
1. De update heeft dependents nodig.
2. Dependents berekenen we uit supports: subject en predicate zijn daar niet voor nodig.

De vraag wordt dan: moeten getters Triples teruggeven om de supports van een berekening te kunnen opstellen? Een analyse per use case.
1. Elementaire (niet samengestelde) berekeningen hebben geen supports. D.w.z. berekeningen op basis van de Rol- en Context data.

2. Compositie van p en q. composeTripleGetters heeft voor de berekening van de supports, als verzameling TripleRefs, nodig:
	- id, nameOfp voor de referentie naar het triple dat resulteert uit de toepassing van p
	- elk van de objectsOfP en nameOfq voor de referentie naar elk van de triples dat wordt berekend met q en een object van p toegepast op id.
	Oftewel: de deelberekeningen hoeven geen triples op te leveren.

3. Combinatoren.
	closure: zoals bij compositie.
	closure': idem
	filter: idem
	concat: hier zijn de namen van p en q en id voldoende. Triples zijn overbodig.
	intersect: als bij concat
	notEmpty: deze combinator hergebruikt de supports van zijn argument.

4. Bij het runnen van een query, om de startpositie in een queryvariabele op te slaan: geen supports.

5. Bij het uitvoeren van een effect. Hier is nodig: de naam van de query en het subject. Daaruit vormen we de support van het triple dat het effect representeert.

Het antwoord op de vraag: "moeten getters Triples teruggeven om de supports van een berekening te kunnen opstellen" luidt daarom: NEEN!
We kunnen in elk van de vijf use cases van memoriseren de supports bepalen zonder dat deelberekeningen triples moeten teruggeven.

DEPENDENCY TRACKING ZONDER TRIPLES
De TripleAdministration bestaat uit een dubbel geïndexeerde StringMap. De twee sleutels zijn: het Subject en het Predicaat. Wat we moeten opslaan, zijn:
	- de objecten;
	- de supports
	- de dependencies

Daarbij ga ik ervan uit dat de predicaatnaam voldoende is om de functie voor berekening terug te kunnen vinden.

FUNCTIES EN PREDICATEN
Het is mogelijk om een Map aan te leggen van functie naar naam en een StrMap van naam naar functie. Daarmee kunnen we een heen-en-weer verbinding realiseren (een IsoMorphism?) tussen Predicaten en de functies die ze berekenen.
Het zou prachtig zijn als we dat in PerspectivesState kwijt kunnen.

DOEL: OBJECTSGETTERS FLEXIBEL MEMORISEREN
1. We hebben alleen nog maar ObjectsGetters.
2. De compositie-operatoren en combinatoren memoriseren al dan niet al naar gelang van een element van PerspectivesState (state in MonadPerspectives).
	- de functies ignoreCache en useCache veranderen. Hun argument wordt een ObjectsGetter.
	- we moeten een default kiezen (standaard memoriseren?)
	- naamgeving: remembering, forgetting?
	- het blijven combinatoren die een ObjectsGetter teruggeven.
3. Ook als ze memoriseren, geven ze een Array String terug.
4. De functie computeAndRemember past een ObjectsGetter toe op een Subject. Maar het is ook mogelijk om een ObjectsGetter rechtstreeks op een Subject toe te passen. In het laatste geval werken remembering en forgetting uiteraard niet.

QUERIES MET EN ZONDER VARIABELEN
Queries zonder variabelen zijn in MonadPerspectives (memoriserend of niet).
Queries met variabelen zijn in MonadPerspectivesQuery.
Queries worden inherent asynchroon uitgevoerd. Elke query-executie moet zijn eigen environment hebben. Elke query-berekening vindt plaats in een Monad-instantie!

Een query is daarmee als een let-blok, waarbij de Monad-State als Frame functioneert. 

De functie rolQuery berekent een functie voor een berekende Rol. Deze functie wordt altijd met runMonadPerspectivesQuery uitgevoerd, zodat hij over een eigen State beschikt.

Dus: door de modelleur gemaakte berekende rollen worden altijd in MonadPerspectivesQuery uitgevoerd. De programmeur heeft keuze. Als hij constateert dat een query geen variabelen gebruikt, kan hij hem in MonadPerspectives uitvoeren. Dat is dan gewoonweg een ObjectsGetter.


REFACTOR-STAPPEN
0. Maak een isomorphie tussen predicaat en ObjectsGetter. KLAAR
1. Ontwerp een Triple zonder Subject en Predicaat: TrackedObject.	KLAAR
2. Herschrijf de TripleAdministratie zodat hij niet met triples werkt maar met TrackedObjects. KLAAR
3. Herschrijf de ObjectsCompositie operatoren zodanig dat ze kunnen memoriseren in termen van TrackedObjects.
4. Schrijf Combinatoren voor ObjectsGetters, die kunnen memoriseren in termen van TrackedObjects.
5. Gebruik de namen van de DataTypeTripleGetters voor de SystemObjectGetters
	- daar waar de SystemObjectGetters namen worden gebruikt, moet je die dus vervangen.
	- Overal moeten types veranderen. TripleGetters worden ObjectsGetters.
6. Gebruik de namen van de ModelBasedTripleGetters voor ModelBasedObjectGetters.
	- daar waar modelBasedObjectGetters namen worden gebruikt, moet je die dus vervangen.
	- de meeste ModelBasedTripleGetters zullen nog geschreven moeten worden in termen van ObjectsGetters.


===================================================================================================================
OPNIEUW: MOETEN WE TRIPLES TERUGGEVEN OM DEPENDENCY TRACKING TE KUNNEN DOEN?
Ik heb een aantal gevallen ontdekt waarin de subjecten en predicaten van triples wel degelijk gebruikt worden (met een search naar "Triple{"):
1. Perspectives.Api: getQuery.

getQuery :: forall e. ContextID -> TypedTripleGetter (react :: REACT | e) -> ReactStateSetter e -> MonadPerspectives (ApiEffects e) (QueryUnsubscriber e)
getQuery cid query@(TypedTripleGetter qn _) setter = do
  (Triple{subject, predicate}) <- cid ## query ~> NamedFunction (cid <> qn) (setter >=> pure <<< const unit)
  pure $ unRegisterTriple $ TripleRef {subject, predicate}

Maar hier kunnen we subject vervangen door cid en predicate door de naam van query, waar query straks gebonden is aan een ObjectsGetter.

2. Perspectives.QueryCombinators: filter. Hier moeten we een andere, echte filter constructie gebruiken.

3. Perspectives.QueryEffect: addEffectToQuery. Hier moeten we in addEffectToQuery' de id als subject meegeven aan effectFun, en de naam van de ObjectsGetter als predicaat.

4. Perspectives.TheoryChange. De queue is inherent en essentieel gebaseerd op triples. 
	a. Inventarisatie van de interface van TheoryChange is: (updateFromSeeds, modifyTriple) en die wordt exclusief gebruikt in Perspectives.Delta.
	b. Alleen updateFromSeeds brengt van buiten triples op de queue naar binnen. 
	c. In Perspectives.Deltas.runInTransactie wordt Perspectives.TheoryChange.modifyTriple aangeroepen met een Delta. Deze functie raadpleegt de Triple administratie, maar zou zonder verlies ook met een TrackedObject administratie uit de voeten kunnen en tòch een Triple teruggeven.
	d. Deze triples gaan naar updateFromSeeds.
	e. In Perspectives.TheorChange.getDependencies kunnen we dan Triples in elkaar schroeven. Zij vormen de queue.

EINDCONCLUSIE
Overal kunnen we om de Triples heen, behalve in TheoryChange. Daar moet de queue bestaan uit Triples. Maar die kunnen we lokaal in elkaar zetten.

