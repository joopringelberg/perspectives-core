De modellenlijst in React

1. Ik heb nu een mechanisme om een rol te berekenen en die berekening willekeurig te kunnen laten triggeren door het dependency systeem. Casu quo, sys:Systeem heeft nu een extra rol "models" en die wordt gevuld doordat we de lijst van documenten uit de couchdb 'perspect_models' halen.

2. Volgende stap: zet die op het scherm.
	a. Maak een lijst of een dropdown lijst in React.
	b. Bed dat in een Rol component van een Context component in, zodat we via de API de betreffende rol kunnen opvragen.

========================================INTERMEZZO========================================
Het is nodig om modelbestanden te kunnen parseren en in Couchdb op te kunnen slaan. Uiteraard is dat waar de editor voor bedoeld is, maar we zitten in een catch22 situatie.
Opgelost via een testfile.

========================================INTERMEZZO========================================
Het mechanisme om een computedRol uit te rekenen, rammelt.
Ik heb het uitgewerkt voor de queryCompiler. Die vertrekt echter uit de ID van een typebeschrijving zoals:
	- model:QueryAst$DataTypeGetter
	- model:QueryAst$PropertyGetter
	- model:QueryAst$RolGetter
	- etc.
Een beschrijving van zo'n type wordt opgesteld door de functie compileElementaryQueryStep. Hij produceert uit de dataconstructor ComputedRol van het sum-type ElementaryQueryStep zo'n beschrijving, van het type model:QueryAst$RolGetter. De functienaam is in dat geval "computedRolGetter", in plaats van "constructRolGetter", "rolQuery", enz.

ElementaryQueryStep-types moeten worden geproduceerd door de parser die een query-expressie ontleedt. Die is nog niet geschreven. Ik stel me voor dat hij zal werken met een lijst van gereserveerde rollen. Bij zo'n gereserveerde rol stelt hij een ComputedRol beschrijving op.

Maar nu is de vraag: hoe kunnen we zo'n soort rol laten berekenen vanuit de React componenten?

Er is dus een moment in de parser waarop een rolnaam bekend is en besloten moet worden of een
	- rolQuery,
	- constructRolLookup,
	- constructInverseRolGetter, of
	- computedRolGetter
constructor moet worden ingezet om de rol op te halen.

Dat proces, iets dergelijks, moet ook gevolgd worden als vanuit een React Context component een rol opgehaald wordt. Immers, ook daar kan het gaan om een
	- berekende rol (rolQuery)
	- een rol die misschien niet direct bij de context is opgeslagen, maar bij een prototype (constructRolLookup)
	- omgekeerde beweging over een rol (constructInverseRolGetter)
	- of een rol die berekend wordt in een willekeurige functie, in plaats van door data-traversal.

Hoe onderscheiden we die gevallen?
Ten eerste, merk op dat de queryFunctionDescriptionCompiler een gevalsonderscheiding doet aan de hand van de test:
	(lift $ rn `contextHasType` "model:Perspectives$Function")
Oftewel: heeft de rol het type psp:Function? In dat geval stelt deze compiler een beschrijving op van een "rolQuery".
Ten tweede: de parser moet al onderscheid maken naar een gekwalificeerde en ongekwalificeerde naam. Het gaat simpelweg om de vraag of een lokale naam is gebruikt, of een naam voorzien van een prefix of zelfs een volledige gekwalificeerde naam (als we dat al toestaan).
Eigenlijk moet hier maar één geval aan toegevoegd worden, namelijk dat de (gekwalificeerde) naam een gereserveerde (want berekende) rol is.
Dit kan ik toevoegen aan de queryFunctionDescriptionCompiler.
Daarbij kan ik gebruik maken van het type van zo'n rol: dat is q:computedRolGetter

In de React interface hebben we alleen maar gekwalificeerde namen. We zouden dus een beschrijving kunnen opstellen van een QualifiedRol. De queryFunctionDescriptionCompiler en de queryCompiler kunnen dan de rest doen.

OPGELOST, GEREPAREERD.
================================================================================

Ik maak alleen een operatie om de view van een Rol op te halen; niet óók een voor externe en interne properties.
De consequentie daarvan is dat de schermbouwer zich bewust moet zijn van binnen- en buitenrol.
Dus bijvoorbeeld:

	<context rollen={["trustedCluster"]}>
		<binding rol="trustedCluster">
			<view viewnaam="buitenRolKaartje">...</view>
			<contextVanRol rollen={...}>
				<binnenRol>
					<view viewnaam="privePropertiesVanCluster">...</view>
				</binnenRol>
			</contextVanRol>
		</binding>

Daar kunnen we drie handige samentrekkingen uit afleiden:
	- externeView = view na binding
	- gebondenContext = contextVanRol na binding
	- interneView = view na binnenRol na contextVanRol na Binding

De component View geeft zijn state (d.w.z. de properties met hun waarden) door aan elke geneste component, behalve als dat een Property component is. Zo'n component noemt een bepaalde property en krijgt een extra prop, 'waarde'.
Dus:

	<View naam="buitenRolKaartje" rol="trustedCluster">
		<Property prop="naam"/>
	</View>

Deze Properties moeten dus op het eerste niveau genest zijn binnen een View component.

Als alternatief schrijft de modelleur zelf een Component, die dus als props de volledige verzameling properties krijgt.

	<View naam="buitenRolKaartje" rol="trustedCluster">
		<MijnEigenView>
	</View>

function MijnEigenView(props)
{
	return <p>En dit is de naam: {props.naam}</p>;
}

================================================================================
DE LIJST VAN MODELLEN
Wat je ophaalt, zijn de IDs van de contexten die de root vormen van een model. Die kun je laten zien zonder dat je de modellen zelf op hoeft te halen.
Dan heeft de berekende rol een resultaat van Contexten.
Maar ik zou er gemakkelijk in de functie "_buitenRol" aan vast kunnen plakken.
Dan heeft de berekende rol een resultaat van (Buiten)Rollen.
Als je de displayname wilt laten zien (en dat wordt belangrijk als we die kunnen veranderen terwijl de onderliggende filenaam/contextID niet verandert), dan *moet* je de modellen zelf ophalen.

Dan speelt de cardinaliteit. Deze rol is niet functioneel.
1. Moet Binding ook werken voor een niet-functionele rol?
2. En View dan?

06 10 85 55 89
