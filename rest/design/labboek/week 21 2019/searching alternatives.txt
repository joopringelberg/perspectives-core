PROBLEEM VAN UNLESSNULL

Er zit een probleem in searchLocallyAndInPrototypeHierarchy. De unlessNull veroorzaakt het probleem. Als de eerste tak faalt, levert de tweede tak op.
Het resultaat heeft dan niet de dependencies van de eerste tak. Maar als later de theorie wijzigt waardoor de eerste tak wèl een resultaat levert, komt dat niet door bij de propagation.
Je wil dat de eerste tak prevaleert. Maar als er geen resultaat uitkomt, dan probeer je de tweede tak.
Mocht er later een resultaat uit de eerste tak komen, dan prevaleert dat alsnog.

DEFINITIE VAN UNLESSNULL
unlessNull werkt in combinatie met Alt. Het is de applicatie van een TripleGetter, die 'empty' levert als het object leeg is.

-- | Combinator to make a TripleGetter fail if it returns an empty result.
-- | Useful in combination with computing alternatives using <|>
unlessNull :: forall s o. (s **> o) -> TripleGetter s o
unlessNull tg id = (id @@ tg) >>= \r@(Triple{object}) -> if (Arr.null object) then empty else pure r

IDEE VAN DE VERBETERING
Wat we willen is dat het resultaat van 'links' gebruikt wordt, als dat niet leeg is. Mocht links leeg zijn, dan berekenen we rechts.
Dit geldt voor elke berekening, dus ook herberekening.

We moeten deze afweging opnieuw maken als links verandert, zowel als voorheen een resultaat opgeleverd werd, als wanneer dat niet zo was.
We zouden dat niet hoeven doen als rechts verandert, zolang links een waarde heeft.

Het te volgen algoritme is dus altijd:
1. Bereken links.
2. Indien niet leeg, lever op.
3. Indien leeg, bereken rechts.

Wat voor dependencies moeten we aanleggen om te garanderen dat op de noodzakelijke momenten de afweging opnieuw wordt gemaakt?
* we hebben altijd een dependency op links nodig.
* de dependency op rechts is alleen nodig als links leeg is.
Oftewel, zodra rechts eenmaal berekend is, voegen we deze dependency toe.

In meer detail:
* we berekenen een triple voor links. 
* dit triple is een support van het resultaat van de unlessNull expressie
* is het object van het triple leeg, dan berekenen we ook rechts.
* dit triple is óók een support van het resultaat van de unlessNull expressie
* het resultaat triple heeft het object van links indien niet leeg; anders het object van rechts.

SYNTAXIS
Ik zou een triplegettercombinator willen maken: 

	preferLeft :: StringTypedTripleGetter -> StringTypedTripleGetter -> StringTypedTripleGetter

OM NA TE GAAN
Worden de dependencies bijgewerkt, bij herberekening? Let op het verschil tussen supports en dependencies.

Het lijkt me dat in TheoryChange.propagateTheoryDeltas een redenering wordt toegepast die niet sluit.
Als een Triple nieuw berekend is en aan de administratie toegevoegd wordt, worden uit de supports nieuwe dependencies afgeleid.
Maar gebeurt dat ook bij herberekening?
Recompute past de getter opnieuw toe, maar registratie van Triples gebeurt meestal door de memorize functie. 
Subtiel verschil: in de TypedTripleGetter is de getter samengesteld met memorize. 
Maar in het Triple is de getter de 'pure' getter - zonder memorize.

Dat is maar goed ook, want anders zou bij herberekening altijd weer hetzelfde resultaat uit de TripleAdministratie geput worden.

Bij propagateTheoryDeltas worden de nieuw berekende supports toegevoegd aan het oude Triple. 
Maar er wordt niet dezelfde conversie naar dependencies gemaakt als bij de oorspronkelijke introductie van het Triple in de administratie. En dat is:

	foreachE supports (addDependency (getRef triple))

1. Stel dat een nieuwe support opgeleverd wordt bij herberekening. Dan moet aan die nieuwe support dus een dependency toegevoegd worden.
2. Stel dat een support verdwijnt bij herberekening. Dan moet bij die support dus een dependency verdwijnen.

Deze afweging moet worden gemaakt bij herberekening!
Het is simpelweg een kwestie van tweemaal het verschil berekenen tussen twee arrays:
* wat zit in de oude supports wat niet in de nieuwe zit - die supports verliezen een dependency;
* wat zit in de nieuwe supports wat niet in de oude zit - die supports krijgen het nieuwe triple als dependency erbij.

TEST VAN PREFERLEFT
Definieer een Context met een binnenrol met twee properties, v1 en v2. 
Maak een instantie met een waarde voor v2.
Vraag op: ($v1 `preferLeft` $v2)
Het resultaat moet de waarde van $v2 zijn.
Geef dan $v1 een waarde.
Vraag nogmaals de waarde van ($v1 `preferLeft` $v2).
Het resultaat moet nu de waarde van $v1 zijn.

Ik kan TestBotActie.crl gebruiken.
Haal de binnenRol property op met: getInternalProperty

Maak de test in TripleGetterComposition.

DEBUGGING
[<model:User$mc1 - 
	preferLeft(
		model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1, 
		v2)>,
<model:User$mc1 - model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1>]

APPLY THE CHANGE THROUGHOUT THE CODE
Ik heb in de TripleGetters zowel unlessFalse als unlessNull vervangen, op één geval na, in ModelBasedStringTripleGetters.
