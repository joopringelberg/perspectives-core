DEBUGGING TESTBOTACTIE IN REACT-INTEGRATED-CLIENT

1. Bij ExternalViewOfBoundContext werkte het wel, maar bij InternalViewOfBoundContext niet.
De inbedding is als volgt:
	<Context type="model:Perspectives$PerspectivesSysteem" contextinstance="model:User$MijnSysteem">
		<Rollen rollen={[
            "gebruiker",
            "modellen",
            "trustedCluster",
            "zaken"
          ]}>
          	...
          	<InternalViewOfBoundContext rolname="zaken" viewname="allProps">
              <TestBotActie/>
            </InternalViewOfBoundContext> 
        </Rollen>
    </Context>

function InternalViewOfBoundContext(props)
{
  return (<RolBinding rolname={props.rolname} rolinstance={props.rolinstance}>
    <ContextOfRole>
      <ViewOnInternalRole viewname={props.viewname}>{props.children}</ViewOnInternalRole>
    </ContextOfRole>
  </RolBinding>);
}

function ViewOnInternalRole(props)
{
  return (<InternalRole contextinstance={props.contextinstance} namespace={props.namespace}>
      <View viewname={props.viewname}>{props.children}</View>
    </InternalRole>)
}


ANDER PROBLEEM
In View mis ik 'namespace' en 'rolname' in de props.

            <RolBinding rolname="trustedCluster">
              <ContextOfRole>
                <ViewOnExternalRole viewname="Kaartje">// Error hier door "Kaartje"
                  <TrustedCluster_BuitenRol_Kaartje />
                </ViewOnExternalRole>
              </ContextOfRole>
            </RolBinding>

function ViewOnExternalRole(props)
{
  return (<ExternalRole contextinstance={props.contextinstance} namespace={props.namespace}>
      <View viewname={props.viewname}>{props.children}</View>
    </ExternalRole>)
}

ExternalRole moet de namespace doorgeven aan View.
ExternalRole roept getRolType van: "model:User$MijnSysteem$MijnCluster_buitenRol"
Hij ontvangt een prop.contextinstance gelijk aan "model:User$MijnSysteem$MijnCluster".
Die bestaat. Maar er komt niets terug.
Het type moet zijn: "model:Perspectives$TrustedCluster$buitenRolBeschrijving"
Dit zou de namespace zijn die hij doorgeeft aan zijn children, casu quo View.
En dan wordt in View de qualifiedView gelijk aan:
"model:Perspectives$TrustedCluster$buitenRolBeschrijving$Kaartje"
En die bestaat.

Dus: waarom komt getRolType niet terug?
OPGELOST.

V1 ZETTEN FAALT
Het request heeft:
	predicate "undefined$undefined$v1"
	subject undefined
	
setProperty blijkt geen prop namespace en geen prop rolinstance te hebben. Alleen propertyname	

Dit is de inbedding:
            <InternalViewOfBoundContext rolname="zaken" viewname="allProps">
              <TestBotActie/>
            </InternalViewOfBoundContext>

function TestBotActie (props)
{
  return (
    <div>
      <p><label>v2:</label>{props.v2}</p>
      <SetProperty propertyname="v1">
        <V1Input/>
      </SetProperty>
    </div>
  );
}

function InternalViewOfBoundContext(props)
{
  return (<RolBinding rolname={props.rolname} rolinstance={props.rolinstance}>
    <ContextOfRole>
      <ViewOnInternalRole viewname={props.viewname}>{props.children}</ViewOnInternalRole>
    </ContextOfRole>
  </RolBinding>);
}

Wat geeft ViewOnInternalRole door? Dat wat InternalRole doorgeeft:
// namespace
// rolinstance

Waarschijnlijk blijft het dus hangen in TestBotActie.
Daar geef ik het nu door, maar het lijkt erop dat TestBotActie zelf de waarden niet ontvangt.

View ontvangt de props van InternalRole.
Maar vermoedelijk geeft View alleen de props door die properties zijn in de view.
Dus dat betekent dat TestBotActie ze niet ontvangt.

Ik ga View ook namespace en rolinstance laten doorgeven.

DE BOT IS NIET OPGEZET VOOR DE TESTCONTEXT (OPGELOST)
setupBotActions wordt wel aangeroepen, maar komt niet tot het toepassen van de actie. 
Hij vindt geen actions.
En dat klopt. Hij probeert het te doen voor de binnenrol!
Gecorrigeerd. 
Maar nu staat de trigger nog niet aan!

DE PROPERTY V2 VERANDERT NIET OP HET SCHERM (OPGELOST)
Ik zie de callback in view wel geactiveerd worden voor de nieuwe waarde van v1, maar niet voor v2, terwijl die wel verandert in de database.
Opgelost!

DE VOORNAAM KAN NIET WORDEN GEZET (OPGELOST)
Het systeem meldt dat 
	model:Perspectives$PerspectivesSysteem$voornaam 
niet kan worden gevonden en dat klopt, want het moet
	model:Perspectives$PerspectivesSysteem$Gebruiker$voornaam
zijn

In de component SetProperty is de namespace gelijk aan 
	"model:Perspectives$PerspectivesSysteem"
De rolname is:
	"gebruiker"

De oplossing zou zijn om de rolname toe te voegen. Maar dan functioneert SetProperty waarschijnlijk niet meer voor 'trigger' en 'v2'.
Daar is namespace gelijk aan:
	model:TestBotActie$Test$binnenRolBeschrijving"
en de rolname is niet gebonden.


            <View rolname="gebruiker" viewname="VolledigeNaam">
              <GebruikerNaam />
              <SetProperty propertyname="voornaam">
                <GebruikerVoornaamInput/>
              </SetProperty>
            </View>
Versus:
            <InternalViewOfBoundContext rolname="zaken" viewname="allProps">
              <TestBotActie/>
            </InternalViewOfBoundContext>

ExternalRole geeft nu als namespace het type van de rol. 
View geeft als namespace de namespace die het ontvangen heeft.
We moeten dus de namespace van het roltype afslopen, in ExternalRole.

Nu ontvangt SetProperty niet de rolname, voor trigger.
Klaar

DE WAARDE VAN EEN PROPERTY VERSCHIJNT NIET ALS DEFAULT IN HET INPUT VELD (OPGELOST)
Wel bij voornaam, niet bij trigger en v1. Opgelost.

TWEEMAAL EEN INSTANTIE VAN TBA:TEST MAKEN FAALT (OPGELOST)
[(IncorrectContextRolBinding) In de context 'model:User$MijnSysteem' is de ContextRol 'model:User$MijnSysteemzaken0' gebonden aan 'model:User$c9e4e9a71_510d_46fc_ac1a_4e8850cdf644'(type: 'model:TestBotActie$Test') maar moet worden gebonden aan een instantie van (één van de) type(s) '["model:Perspectives$Zaak"]'.]
Dit is de eerstgemaakte binding. Kennelijk wordt die opnieuw gecontroleerd bij het aanmaken van een tweede instantie.

EEN NIEUWE INSTANTIE VAN TBA:TEST KOMT NIET DOOR OP DE USER INTERFACE (OPGELOST)
Tijdelijk opgelost door checkAContext uit te zetten.

EEN PROPERTY DIE MEEGEGEVEN WORDT BIJ HET AANMAKEN VAN EEN CONTEXT KOMT NIET OVER (OPGELOST)
"[(PropertyNotDefined) De Rol 'model:User$MijnSysteem$gebruiker_1' van de context 'model:User$MijnSysteem' geeft een waarde aan Property 'model:Perspectives$PerspectivesSysteem$voornaam' maar die is niet gedefinieerd voor 'model:Perspectives$PerspectivesSysteem$gebruiker'.]"

DE EERSTE TESTCONTEXT VERSCHIJNT NIET DIRECT OP HET SCHERM (OPGELOST)
Alle volgende wel. Delta's worden gemaakt.
"conj(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$trigger not((equal model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2 model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)))"
Dit is de conditie.
En die gaat een EffectFun in. Dat klopt, dat is voor de bot die opgezet wordt voor de nieuwe context.
Maar alhoewel de "zaken" zijn opgevraagd, worden ze niet doorgegeven.

Er wordt een goede Delta aan modifyTriple aangeboden.

In modifyTriple wordt het onderliggende Triple opgezocht en aangepast.
Dit blijkt echter geen dependencies te hebben en ook geen supports. Dat verklaart waarom er geen propagation plaatsvindt.
Maar waarom niet?

Dit triple moet zijn aangelegd bij het opvragen van de rol "zaken" bij "model:User$MijnSysteem"

predicate: "model:Perspectives$PerspectivesSysteem$zaken"

Ik zie bij registerTriple wel dit langskomen:
"model:Perspectives$buitenRol >-> model:Perspectives$binding >-> model:Perspectives$context >-> model:Perspectives$PerspectivesSysteem$zaken"
en:

"model:Perspectives$PerspectivesSysteem$zaken ~> 3"
en deze heeft de vorige als support.

Als er wèl een TestContext is, dan is de support "model:Perspectives$PerspectivesSysteem$zaken"
Zo hoort het.

De lange is de neerslag van de poging om 'zaken' bij het prototype te vinden. Het is niet gelukt bij Systeem zelf. En daar is ook geen support voor aangelegd, zodat, als er een instantie bijkomt, er niets gebeurt.

Dit heeft te maken met de manier waarop support wordt geregistreerd in >->.

Als er geen zaak is, wordt er geen triple geregistreerd.

NEEN, toch niet. Het zit in searchLocallyAndInPrototypeHierarchy. De unlessNull veroorzaakt het probleem. Als de eerste tak faalt, levert de tweede tak op.
Het resultaat heeft dan niet de dependencies van de eerste tak. Maar als later de theorie wijzigt waardoor de eerste tak wèl een resultaat levert, komt dat niet door bij de propagation.
Je wil dat de eerste tak prevaleert. Maar als er geen resultaat uitkomt, dan probeer je de tweede tak.
Mocht er later een resultaat uit de eerste tak komen, dan prevaleert dat alsnog.

RESULTATEN VAN DE BOTACTIE VAN EEN NIEUW AANGEMAAKTE TESTCONTEXT KOMEN NIET DOOR OP DE GUI (OPGELOST)
De botacties worden wel opgezet bij aanmaak van een nieuwe context.
En dan nog een keer bij het zetten van de property.
De acties worden ook uitgevoerd (want resultaten komen in de database). Maar het resultaat komt niet door naar de GUI.

==================== NOG OPLOSSEN ====================




