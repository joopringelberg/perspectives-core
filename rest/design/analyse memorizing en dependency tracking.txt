Op welk niveau moeten functies een naam hebben om de afhankelijkheden goed te administreren?

HUIDIGE SITUATIE
Waar namen gegeven worden:

In Location.purs:
	- memorizeMonadicFunction
In Property.purs:
	- getString(s)
	- getNumber(s)
	- getBoolean
	- getResource(s)
In PropertyComposition.purs:
	- memorizeSingleGetter
	- memorizePluralGetter
	- pToS (>>->)
	- pTop (>>->>)
In QueryCombinators:
	- cons
	- identity
	- hasValue
In SystemQueries.purs:
	- identifier
	- types
	- superClasses
	- typeSuperClasses

WANNEER MOET EEN FUNCTIE EEN NAAM HEBBEN?
Als hij als argument aangeboden wordt aan:
	- connectLocations
	- connectLocationsAsInBind
	- locationDependent
	- nestLocationInMonad
	- in deze class instance functions van Location:
		- map
		- apply
		- bind
	- traverseLoc (maar wordt niet gebruikt)

Verder moeten de functies die gegenereerd worden met property composition operatoren óók een naam hebben.
Immers, in 
	(QC.addTo rdfType (rdfType >->> superClasses)
gebruikt QC.addTo de naam van de door de >->> compositie operator opgeleverde functie. 
Het algemene argument is dat de composition operatoren, èn de combinatoren, een Memorizing getter opleveren en dat deze weer voor verdere compositie gebruikt kunnen worden.
Deze functies moeten dus een naam moeten hebben. Bijvoorbeeld:
	f>->>g
Dit is voor alle operatoren en combinatoren geregeld.

IS HET ZINVOL?
2. In de get(Type>)(s) functies niet in directe zin. Er wordt niet in gememoriseerd.
3. In nestLocationInMonad wel. Daar wordt gememoriseerd dmv connectLocations en locationDependent.
4. In pToS en pToP wel. Daar wordt gememoriseerd dmv connectLocations en locationDependent.
5. QueryCombinators:
	- mclosure past naamgeving en memorisering goed toe.
	- concat is ok
	- addTo is ok
	- identity is ok	
	- hasValue mapt over een Location en zou daarom ok moeten zijn.
	
	Nog doen:
	- aclosure (naamgeving, memoriseren en hergebruik)
	- filter (hergebruik)
	
6. In SystemQueries: NALOPEN!!
	- identifier is een MemorizingSingleGetter en moet een naam hebben. NB QUERYSTAP?
	- types gebruikt memorizeMonadicFunction. De gegenereerde functie (QC.mclosure rdfType) moet dus een naam hebben. mclosure genereert een anonieme functie.
	- superClasses wordt gegenereerd door (QC.aclosure subClassOf). aclosure genereert een anonieme functie.
	- typeSuperClasses is een functie gegenereerd door >->> en die geeft geen naam.

NAAMGEVING
Combinatoren en compositie operatoren vat ik samen onder de naam 'combinatoren.
Elke combinator moet een functie opleveren die een naam heeft. Deze namen zijn samengesteld uit de namen van de componenten waar de combinator op is toegepast.
De componenten zijn immers functies waar hetzelfde voor geldt: ze moeten een naam hebben.
Een combinator kan een structuur van afhankelijke locaties opzetten bovenop de structuur die zijn componenten aanmaken. De combinator moet de verbindingen in die structuur een naam geven. Voorbeelden:
	- de sTos combinator legt geen extra structuur aan bovenop de verbindingen die de participerende singlegetters aanleggen;
	- de pTos combinator construeert twee arrays, waarvan de tweede in een locatie opgeslagen wordt en het eindresultaat van de combinatie vormt. Deze locatie is afhankelijk van het resultaat van de eerste component en de gebruikte naam is die van de tweede component.
