ACE FOLDING
We willen een fold op:
	- type declaration
	- (later) property assignment met een waarde die zich over meerdere regels uitstrekt.
	- multiline commentaar
	- meerdere single line commentaar regels
Kunnen we dat vinden in termen van reguliere expressies?
1. Als type declaratie op één regel is, hoeft er niet gevouwen te worden.
2. anders wel, dus match:
	resourceName '=>'$
NB: denk aan commentaar!

Maar hoe vind je het eind?
Het gaat om indentering.
Dus:
1. bepaal de beginkolom van de typedeclaration.
2. vind de regel waar op de beginkolom weer tekst staat. De regel ervoor is het eind.

ACE INDENTING
We willen inspringen na:
	- context declaration
	- rol declaration (roleBinding)
Er zijn geen omstandigheden waaronder we automatisch kunnen terugspringen, althans niet op basis van de grammatica.

ACE SYNTAX HIGHLIGHTING
We hebben de volgende typen expressies:
1.	type declaratie: :Aangifte :a1; 
2.	public context property assignment: public :urgentie = 7;
3.	private context property assignment: private :aantekening = “…”;
4.	rolbinding: :aangever => :Jansen; 
5.	rol property assignment: :betrouwbaarheid = 6.
6. query: query :aangever binding
7. inline typedeclaration en daar gaat het vooral om het bindingsdeel: :aangever =>
NB: denk aan commentaar!

Kunnen we deze situaties met pattern matching en states herkennen?
Onderstaande expressies zijn met een regexp te herkennen:
2.	public context property assignment: public :urgentie = 7;
3.	private context property assignment: private :aantekening = “…”;
4.	rolbinding: :aangever => :Jansen; 
5.	rol property assignment: :betrouwbaarheid = 6.
6. query: query :aangever binding
7. inline typedeclaration en daar gaat het vooral om het bindingsdeel: :aangever =>

Blijft over:
1.	type declaratie: :Aangifte :a1; 
Dit valt te matchen en bovendien is het het overblijvende geval.

Uitwerken:
1. Maak een regexp voor elke expressie, die de hele regel dekt in matching groups
2. Geef elk onderdeel een token.
3. Definieer css voor de tokens.

UITZOEKEN
1. Ik zie in de json_worker.js file dat json geparsed wordt en meldingen toegevoegd worden aan een array met errors dat door de worker ge-emit worden (naar Ace, neem ik aan) onder de vlag "annotate".

TODO
1a. RegExps voor commentaar in highlighting. KLAAR
1b. Indenting. KLAAR
1c. Folding KLAAR
2. Breid de contextRoleParser uit met parsers voor commentaar.
2a. Zet de voorbeeld tekst in de editor. KLAAR
3. Breid de contextRoleParser uit met parsers voor 'text' KLAAR met prefixes.
4. Definieer de context 'text'.
5. Definieer de context 'domein'.

=================================================================
0. Parseer de huidige regel.
	I. Indien niet correct:
		1. Bepaal de vorige (niet-commentaar) regel in hetzelfde blok.
		2. Bepaal welke expressies daarop mogen volgen.
		3. Detecteer welke expressie de gebruiker opbouwt.
			a. Indien dat niet één van de toegelaten expressies is, geef een foutmelding.
			b. Anders: geef het model van de expressie als hint.
			c. Indien nog niets is ingetikt: geef de mogelijke expressies als hint.
	II. Indien correct: 
		1. Bepaal het tekstblok aan de linkerkantlijn waar deze expressie in voorkomt.
		2. Parseer het hele blok.
		3. Bepaal de update commando's.

=================================================================
* verlaat de identifier van een contextdeclaratie na bewerking ervan
* verlaat de regel na bewerking ervan
* verwijder regelovergang
* voeg regelovergang toe
* laat blok inspringen of terugspringen
* knip (meerdere regels)
* plak (meerdere regels)
* verwijder (meerdere regels)

* bepaal het blok met dezelfde indentering waar een regel in voorkomt
* bepaal het top level blok waar een regel in voorkomt

Een regel die direct gevolgd wordt door een ingesprongen blok is
	- een context declaration, of 
	- een rol declaration
We noemen de combinatie van declaration en blok een **definitie** (van een context of rol). Zo'n definitie bestaat dus uit:
	- de declaratie, gevolgd door
	- een ingesprongen blok.
	
De **definitie waarvan een regel onderdeel is**, is altijd **de omhullende definitie**.
LET OP: voor een declaratieregel is dat dus **niet** de definitie waarvan het de declaratie is!

ALS de identifier van een contextdeclaratie verlaten wordt na bewerking:
	* bepaal de oorspronkelijke naam van de context (de identifier vóór bewerking van de regel);
	* vervang de oude context door de nieuwe context. D.w.z.: 
		- speur alle rollen op die de oude context als binding hadden
		- vervang die binding door de nieuwe context.

ALS een regel verlaten wordt nadat hij bewerkt is:
	* bepaal de definitie waarvan de regel onderdeel is (dus de omhullende definitie!)
	* parseer dat blok tot een context of rol
	* ALS dat slaagt:
		* bepaal de updates
	* ANDERS:
		* bewaar de oude situatie tot het moment dat de tekst weer wel geparseerd kan worden.
		
Een regelovergang toevoegen kan op dezelfde manier behandeld worden.

ALS een regelovergang verwijderd wordt
IS HETZELFDE ALS: 
	- Knip meerdere regels
	- Verwijder meerdere regels

Hanteer zo'n situatie door achtereenvolgende bewerkingen af te wachten totdat de tekst weer parseerbaar is.
Dan vergelijk je de oude met de nieuwe situatie. De moeilijkheid is vooral om verwijderde contexten of rollen te vinden.

Bovendien is er het verschil tussen verwijderen uit de tekst, en verwijderen uit de bubble.
En de kwestie van meerdere rollen met dezelfde naam (volgnummers), oftewel naamgeving van rol(instanties).

ROLLEN EN CONTEXTEN VERWIJDEREN UIT TEKST EN UIT HET UNIVERSUM
Een rol kan niet los van zijn context bestaan. Dus als een rol na een tekstwijziging niet meer voorkomt, is hij definitief verwijderd. De rollen die met zo'n rol gevuld waren, moeten worden opgespoord en van hun binding ontdaan.
Dat is omdat een contextdefinitie altijd *volledig* is. We laten nooit slechts een deel ervan zien in de tekst.

(Nuancering: Niet alle rollen en properties van een context hoeven te worden getoond in de editor. De auteur bijvoorbeeld kan wel worden verborgen (het beeld wordt verstoord als die informatie bij elke context staat). Uiteraard kun je via tekstwijzigingen zulke rollen en properties niet aanpassen, laat staan verwijderen.)

Geldt dat ook voor een (inline gedefinieerde) context? 
Ik denk van niet.
Om te beginnen, merk op dat inline tonen een verschijnsel is dat gebonden is aan een bepaalde tekst.
Bovendien is het een vorm van weergeven, die willekeurig en misschien wel op last van de gebruiker veranderen kan.
Het structurele kenmerk is dat de buitenrol van een context gebonden is aan een andere rol.
De vraag is dus of voor elke context moet gelden dat hij op elk moment gebonden is aan een rol.
En wat voor soort rol dat dan moet zijn. Want gebonden zijn aan een text_Item rol lijkt me geen voldoende raison d'etre, bijvoorbeeld.
Of toch wel?
Zolang een context een betrokkene heeft, kan hij niet verwijderd worden, tenzij die betrokkene ervoor kiest of ermee instemt.
Een context zonder betrokkenen zou verwijderd kunnen worden, alhoewel zijn buitenrol nog wel rollen kan vullen en dus niet verwijderd mag worden.

Dit lijkt te botsen met het volgende principe: dat een property van een rol, bijvoorbeeld, alleen binnen de context van die rol gedefinieerd is. We bedoelen daarmee dat alleen instanties van die rol die property kunnen hebben. Een andere rol kan een property met dezelfde naam hebben, maar die heeft dan ook een eigen, mogelijke andere, definitie.

Toch zijn beide principes (property exclusief voor rol en context heeft bestaansrecht onafhankelijk van binding van zijn buitenrol) te verenigen. Dat een property exclusief is voor een rol, is een principe dat slechts betekenis heeft op het niveau van *definities* van rollen en properties. *Niet* op het niveau van instanties van contexten en rollen (en hun property-waarden).
Met andere woorden: als de modelleur een context declaratie verwijderd die een Property definitie representeert, mag het systeem op basis van de semantiek van definities van properties concluderen dat deze context geheel uit het systeem verwijderd mag worden (als er geen andere belemmeringen zijn, zoals een co-auteur die moet instemmen).
Hetzelfde geldt als hij een rolbinding naar zo'n Property definitie verwijdert. Alhoewel het denkbaar is dat hij hem wil overhevelen van de ene naar de andere rol. 
Wel een semantische constraint: een losse rol of property in een context is niet OK.

Kortom: als een context na een tekstwijziging niet meer voorkomt, is hij niet noodzakelijkerwijs definitief verwijderd maar alleen uit de tekst verwijderd. Het kàn wel (zie het voorbeeld van een property definitie). Een willekeurige context definitief verwijderen vergt een andere actie.


SCOPING
Het voorkomen van twee property-definities in verschillende context-definities met dezelfde naam lijkt overigens wel een probleem. Immers, namen zijn globaal in de namespace. Hoe lossen we dat op? Dit is een vraag naar scoping.

Een domein(-definitie?) introduceert een scope voor context-definities en roldefinities (rollen van het domein).
Een context-definitie introduceert een scope voor rol- en propertydefinities.
Een rol-definitie introduceert een scope voor PropertyPerspectief definities.

Om definities met dezelfde naam uit verschillende domeinen van elkaar te onderscheiden, gebruiken we namespacing.

Wat gebruiken we voor context- en roldefinities?
Dat moet ook een vorm van namespacing zijn. Je krijgt dan zoiets:

Volledige naam:												Lokale naam:
model:PolitieDomein#Aangifte								pol:Aangifte
model:PolitieDomein#Aangifte#Aangever						#Aangever
model:PolitieDomein#Aangifte#Aangever#Betrouwbaarheid.		#Betrouwbaarheid

Voor domeinen gebruiken we prefixes. Je zou dan naar de rol Aangever van Aangifte binnen model:PolitieDomein (met prefix pol) kunnen verwijzen met:
	pol:Aangifte#Aangever

Als een rol-definitie in tekst is ingebed in zijn context definitie, kun je volstaan met de lokale rolnaam (#Aangever).
Als de rol-definitie in tekst op top niveau is opgenomen, moet je een gekwalificeerde naam gebruiken, b.v.: pol:Aangifte#Aangever.

MEERDERE INSTANTIES VAN DEZELFDE ROL
We lossen dit op met de volgende syntax:
	:rolNaam (1) => :Binding1
	:rolNaam (2) => :Binding2
Het nummer is niet verplicht als er maar één instantie is:
	:rolNaam => :Binding
Deze constraint is semantisch, want komt voort uit het tellen van rollen (en dat is niet context-vrij!).
We kunnen dit dus nog niet afdwingen.
Het volgnummer wordt onderdeel van de naam van de instantie van de rol. Deze wordt opgebouwd uit de naam van de context (een instantie!), de lokale rolnaam en het volgnummer:
	<contextnaam>_<roltypenaam>_n

BETER:
* identifiers van items in couchdb moeten stabiel zijn.
* daarom construeren we vaste ids voor beide, en
* daarnaast zijn er presentatienamen.
* voor een context kan de id beginnen als de ingetikte naam. Hij wordt geconstrueerd als:
	model:<DomeinNaam>#<ingetikteNaam>
  Wijzigt de modelleur daarna de ingetikte naam, dan blijft de id hetzelfde.
* voor een rol construeren we een identifier zoals hierboven: <contextnaam>_<roltypenaam>_n
* daarnaast heeft een rol een property volgnummer.
De volgorde van rollen kan nu wijzigen zonder dat de identifiers hoeven worden aangepast.

In tekst schrijven we een naam, al naar gelang de tekstuele scope waarin hij voorkomt, meer of minder gekwalificeerd.

HOE LEIDEN WE INFORMATIE TERUG NAAR DE EDITOR?
Een simpele manier is om tekst te prettyprinten. We weten precies om welk tekstblok het over gaat.

ROLNUMMERING MEENEMEN IN DE PARSER
Omdat in de parser roleBinding al de naam van de rol wordt gemaakt, moet je daar direct het volgnummer kunnen gebruiken. De aangewezen manier om dat te doen, is de State monad te gebruiken om een telling van rollen bij te houden.
Bij begin van een context initialiseer je die; aan het eind zet je de oude waarde terug.
Maar: hoe stapel je de StateT monad transformer?
De IndentParser is een mooi voorbeeld. Die voegt namelijk StateT toe aan ParserT, die op zich al gebaseerd is op StateT!





