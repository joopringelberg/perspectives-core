SCENARIO PARSER ARC

De parser start met een nieuwe of bestaande instantie van psp:GepresenteerdContextType.
Een instantie komt op één van twee manieren tot stand:
	- de modelleur maakt een lege, nieuwe tekst aan. Hier wordt een guid voor de local name gegenereerd en een default tekst voor de displayName:
		Tekst "Vervang dit door een naam voor de tekst"
		Omhullende Context is 
	- de modelleur maakt een nieuwe tekst aan voor een bestaande context. Nu wordt de local name gevormd uit de context local name en het suffix "_Text". De tekst luidt als volgt:
		Tekst "Tekst van <contextnaam>"
		Omhullende Context is <contextnaam>

De correspondentie tussen deze twee expressies en de onderliggende en tussenliggende representatie is als volgt:
	- de tekst-declaratie wordt opgebouwd uit de displayName van de instantie van psp:GepresenteerdContextType
	- de omhullende-context-declaratie wordt opgebouwd uit de displayName van de context die de binding is van de rol psp:context van de instantie van psp:GepresenteerdContextType.

Het standaard scenario is: de parser krijgt een aantal regels tekst aangeboden die zijn ingevoegd of weggehaald.
De positie van de cursor vóór de bewerking is zowel bij remove als insert, 'start' van het DocumentEvent.

COMMENTAAR RONDOM DE TEKST- EN OMHULLENDE CONTEXTDECLARATIE
Het psp:inlineCommentaar van een psp:GepresenteerdContextType wordt afgedrukt als commentaar achter de tekst-declaratie expressie. Commentaar onder de tekst-declaratie wordt gerepresenteerd als commentaar met een kleiner volgnummer dan psp:context. 
Deze twee vormen van commentaar worden alleen afgedrukt voor een GepresenteerdContextType dat de root van de zichtbare tekst is. 

Het psp:inlineCommentaar van de rol psp:context wordt afgedrukt als commentaar achter de context-declaratie regel. Dit wordt altijd afgedrukt, hetzij achter de omhullende-context declaratie, hetzij achter een gewone context-declaratie.

REGELNUMMERS EN PARSE TREE ONDERDELEN
Elk parse tree onderdeel dat een deel van de tekst produceert (of daaruit volgt) is 1 regel lang of heeft de property 'aantalTekstRegels'. Er zijn maar twee soorten onderdelen die dat hebben, namelijk commentaar en GepresenteerdContextType.

REGELS EN PARSE TREE ONDERDELEN
De rollen psp:import, psp:commentaar en psp:sectie hebben een 1 op 1 relatie met tekstregels (alleen commentaar kan meerdere regels betreffen). Deze tekstregels worden dus alléén in de tussenrepresentatie opgeslagen.

De tekst-declaratie expressie correspondeert met GepresenteerdContextType zelf (zie hierboven), en is daarmee óók zuiver en alleen vastgelegd in de tussenrepresentatie.

De omhullende-context-declaratie correspondeert met de rol psp:context (zie hierboven).

De overige expressies corresponderen allemaal met psp:rol instanties. Deze rol wordt altijd gevuld met een instantie van psp:GepresenteerdContextType. De psp:context rol daarvan levert de onderliggende representatie waaruit de regel wordt opgebouwd. Het gaat daarbij om alle regels in de Arc tekst waarin we een naam declareren.

Maar we hebben diverse soorten declaratie-expressies: context-, property-, view-, rol-, query- en actiedeclaraties.

Deze soorten expressies corresponderen 1 op 1 met de types van de binding van de psp:context rol. Dus: is de psp:context gebonden aan een instantie van Context? Dan hebben we een context-declaratie expressie. Enz.

Er zijn dus 3 + 2 + 6 = 11 soorten expressies (waarbij omhullende-context en context-declaratie als 1 gerekend worden).
	
VIEW
Een view is in de tussenrepresentatie aanwezig als een GepresenteerdContextType met psp:aantalTekstregels > 1, maar die heeft geen onderdelen. Daarvoor moet je naar de onderliggende representatie van de view: psp:View. Die heeft rollen psp:propertyReferentie. De psp:View zelf correspondeert met een regel en elke referentie óók.
Dus als je de opsomming van properties van een view wijzigt (aanvult, verandert, eruit weghaalt) dan verander je de rollen van een psp:View context. Van de tussenrepresentatie verandert alleen psp:aantalTekstRegels van de instantie van GepresenteerdContextType (en al zijn contexten).
Het is niet mogelijk commentaar achter of tussen of onder de de regels van een view te zetten waar een property op staat. Om die reden zou ik er de voorkeur aan geven om de properties van een view achter elkaar op te sommen:

	views
		adres heeft huisnummer, straatnaam, postcode, woonplaats

Iets dergelijks gaat gelden voor de facetten van properties: die spreid zich ook uit over meerdere regels die niet in de tussenrepresentatie benoemd worden.

ARC ROL-EXPRESSIES
Soorten rol-expressies
	- lege rol: 
		"verbalisant (Functioneel)"
	- rol met verwijzing: 
		"verbalisant (Functioneel) gevuld door Medewerker"
Deze varianten hebben beide optioneel nog de 'heeft' clause, die onderverdeeld is in secties. Een grammatica:

rol = 
	Localname Ariteit PropertiesAndViews? |
	Localname Ariteit "gevuld door" Referentie PropertiesAndViews? |
Ariteit = "(" "Niet"? "Functioneel" ")"
Referentie = LocalName | QualifiedName
PropertiesAndViews = "heeft" ("properties" property+)? ("views" View+)?

ALGORITME: VINDT HET AANTAL TEKSTREGELS VAN EEN ROL VAN GEPRESENTEERDCONTEXTTYPE
0. Is de rol psp:context, psp:import of psp:sectie? Dan is het aantal regels 1.
1. Is de rol psp:commentaar? Dan is het aantal regels gelijk aan de property aantalTekstregels.
2. Is de rol psp:rol? Dan is het aantal regels gelijk aan de property psp:aantalTekstregels van de instantie van GepresenteerdContextType die aan de rol is gebonden.

ALGORITME: VINDT HET CORRESPONDERENDE ELEMENT BIJ EEN REGEL
Het element dat dit algoritme vindt is één van:
	- psp:context
	- psp:import, 
	- psp:commentaar of 
	- psp:sectie.

Bepaal het element in de parse tree dat correspondeert met de gezochte regel als volgt.
0. Begin:
	- element = de instantie van psp:GepresenteerdContextType die de tekst zijn naam verleend.
	- R is het gezochte regelnummer 
	- HR = 1 is het huidige regelnummer.
1. Als HR == R, element het gezochte element. EINDE.
2. Doorloop anders achtereenvolgens de naar psp:volgnummer geordende rollen van het element. Kies de eerste rol.
3. Zolang HR + aantalRegels(element) < R: 
	- HR = HR + aantalRegels(element). 
	- element = de volgende rol.
4. Als  HR + aantalRegels(element) > R: 
	- als de het element de rol psp:commentaar is, dan is die rol het gezochte element. EINDE.
	- anders is het element een instantie van psp:rol, per definitie gebonden aan een instantie van GepresenteerdContextType.
		- als het type van de psp:binding daarvan psp:View is: element is het gezochte element. EINDE.
		- anders herhaal vanaf stap 1 met:
			- element = binding van de psp:rol, d.w.z. een instantie van GepresenteerdContextType.
			- R
			- HR = HR

Merk op dat het gevonden element correspondeert met een tekstregel van vóór de wijziging!

ÉÉN REGEL PARSEREN
Als de wijziging maar één regel betreft, zet dan de parser in die correspondeert met het gevonden element. Als de parse slaagt, wijzig dan het gevonden element. 
Slaagt hij niet, dan parseer je de tekst die correspondeert met de context van het element. Motivatie: de veranderde regel kan een correct ander type beschrijven, maar dat hoeft niet in de context te passen. Denk aan een sectie: als de modelleur 'extern' in 'intern' verandert, maar er wàs al een sectie 'intern', is er iets mis.

CONTEXT VAN EEN ELEMENT VAN DE PARSE TREE
Wat is de context van een element?
Voor een rol is dat natuurlijk de context van die rol (dit geldt dus voor 1 t/m 4 hierboven). Voor een GepresenteerdContextType is de omhullende GepresenteerdContextType instantie. Hiertoe moeten we links dubbel representeren, zodat je vanuit een context of rol óók naar de rol kunt waar hij in is gebonden.
In alle gevallen is de context van een element dus een instantie van GepresenteerdContextType.

ALGORITME: VINDT CONTEXT VAN ELEMENT
0. Stel E op het element waarvan we de context zoeken.
1. Als E een rol is (het type psp:Rol heeft), dan is de gezochte context de context van die rol.
2. Als E een GepresenteerdContextType is, dan is de gezochte context de context van de rol psp:context waar E de binding van is.

MEERDERE REGELS PARSEREN
Als de wijziging meerdere regels betreft, parseer dan direct de tekst die correspondeert met het omhullende element.
Maar daarbij mogen we niet uitgaan van het element dat correspondeert met de regel die door 'start' van het DocumentEvent wordt aangegeven.

We moeten de regel in lines (de ingevoegde, danwel verwijderde tekst) vinden met de kleinste indentering. Als de regel, aangegeven door 'start', een kleinere indentering heeft, beginnen we daar met zoeken.
Heeft die regel een grotere indentering, dan moeten we het element vinden waarvan de tekst boven deze regel begint, minder geïndenteerd dan deze regel!

INDENTERING
Ik ga ervan uit dat psp:GepresenteerdContextType een property psp:indent heeft.
Voor de instantie van psp:GepresenteerdContextType die de root van de tekst is: alle rollen hebben indent=0.
Voor alle andere instanties van psp:GepresenteerdContextType:
- alle rollen hebben indent = indent context + 1, behalve
- psp:sectie voor 'intern' en 'extern' heeft indent = indent context + 2.
 
 We kunnen voor elk element de indentering bepalen met dit algoritme:
 
0. Is het element een rol van de instantie van psp:GepresenteerdContextType? Dan
	- als dat de root van de tekst is, is indent = 0;
	- anders is indent de waarde psp:indent van het element.
1. Anders: 
	- alle rollen hebben indent = indent context + 1, behalve
	- psp:sectie voor 'intern' en 'extern' heeft indent = indent context + 2.

ALGORITME: BEPAAL BEGIN PARSERING BIJ MEERDERE GEWIJZIGDE REGELS
0. Bepaal de kleinste indentering in 'lines' en stel die op I.
1. Bepaal het element E dat (in de oorspronkelijke tekst) correspondeert met 'start'.
2. Als:
	- E een psp:Context is, gebonden aan een instantie van psp:View, 
	EN
	- I == Indent(E) + 1
	EN
	- 'start' is groter dan het regelnummer van E (dus de view declaratie regel zelf is niet veranderd!)
	dan is E het gezochte element. EINDE.
2. Anders: stel I op het minimum van I en indent(E).
3. Zoek de context van E met indent = I - 1.

WAT IS DE BEGINREGEL VAN EEN ELEMENT VAN DE PARSETREE?
Gegeven een element van de parsetree, met welke regel in de tekst correspondeert het? We houden regelnummers niet bij in de parsetree, alleen de hoeveelheid regels die door een element worden gegenereerd (en waar het uit wordt geparseerd).

MEERDERE REGELS PARSER
Bepaal het begin-element van parsering bij meerdere tekstregels. Het resultaat is per constructie een GepresenteerdContextType, dat we de naam E geven.
Bepaal vervolgens de (eerste) regel tekst die correspondeert met het element, die we R noemen.
De psp:indent van E noemen we I.

De eerste regel is per constructie (zie het algoritme voor het vinden van het begin element bij het parseren van meerdere regels) NIET gewijzigd. Zie hieronder voor de te volgen strategie als de hele tekst moet worden geparseerd.

Deze eerste regel slaan we over en we construeren de parser state die zou ontstaan als we die regel wèl hadden geparseerd:
ParserState:
	regelnummer = R + 1 (kolom is waarschijnlijk de eerste non-space kolom)
	indentering = I
	huidigeTekstContext = E
	huidigeContext = psp:context van E
	volgnummer = 1
	gevondenRollen = []

Nu kunnen we beginnen met het parseren van de erop volgende regels. We passen daar de volledige parser op toe, d.w.z. een disjunctie van parsers voor:
	- de 6 declaratie-expressies, gebundeld in één 'psp:rol' parser
	- een import-expressie
	- een commentaar-expressie
	- een sectie-expressie
	- de tekst-declaratie-expressie
	- de omhullende-context-declaratie-expressie

CONTEXT-DECLARATIE
Er zijn diverse soorten declaratie-expressies: context-, property-, view-, rol-, query- en actiedeclaraties.
Voor elk hebben we een deelparser die resulteert in een context die de betreffende declaratie beschrijft.
WE NEMEN AAN DAT DE DISPLAYNAME NIET IS VERANDERD, zodat we een reeds bestaande context kunnen terugvinden en zo nodig aan kunnen passen, of een nieuwe context kunnen aanmaken, verbinden met de huidigeContext via de huidigeRol en opslaan.
Dit is allemaal op het niveau van de basisrepresentatie.
Het resultaat van deze deelparsers is een purescript Tuple van de ID van de betreffende context en het eventuele inline commentaar.

Vervolgens zoeken we in de huidigeTekstContext naar de psp:rol waarvan de binding, een instantie van psp:GepresenteerdContextType, een psp:context heeft met de betreffende ID. We passen dan zo nodig het inlineCommentaar van de psp:GepresenteerdContextType instantie aan en de psp:contextRolnaam en het psp:volgnummer van de psp:rol.
Bestaat die niet, dan maken we deze structuur aan, met voor de psp:rol de juiste psp:contextRolnaam en psp:volgnummer en het inlineCommentaar in de psp:GepresenteerdContextType instantie.

De parserState wordt aangepast.
ParserState:
	regelnummer = aangepast door de declaratie-expressie parser (merk op dat de view-parsers meer dan 1 regel kan verwerken)
	indentering = aangepast door de declaratie-expressie parser
	huidigeContext = de ID uit het purescript Tuple
	huidigeTekstContext = de gevonden of geconstrueerde instantie
	volgnummer = 1
	gevondenRollen = []

Daarna wordt, met verhoogde indentering, de volledige parser weer toegepast.
Daarna kunnen aan de hand van de inhoud van gevondenRollen, rollen van de huidigeTekstContext worden opgeruimd.
Vervolgens moet de parser state weer gedeeltelijk hersteld worden (indentering, huidigeContext, huidigeTekstContext, volgnummer, gevondenRollen), waarna de gehele parser weer wordt toegepast.

IMPORT-EXPRESSIE
De import-expressie (psp:import). Deze past een Arc parser toe voor de expressie 'import'. Hij zoekt vervolgens in de rollen van de huidigeTeksContext naar de instanties van psp:import. In die instanties zoekt hij de rol met de betreffende identifier.
	- als die wordt gevonden, werkt hij daarin de prefix bij, het volgnummer en het inline commentaar.
	- wordt hij niet gevonden, dan voegt hij een nieuwe rol met de geparseerde karakteristieken toe.
	ParserState:
	- voeg de rol toe aan gevondenRollen;
	- verhoog het volgnummer.

COMMENTAAR-EXPRESSIE
De commentaar-expressie (psp:commentaar). Deze past een Arc parser toe voor de expressie 'commentaar'. Die levert een purescript data type waarin de tekst en het aantal regels zit. 
	Vervolgens:
	- als het element met hetzelfde volgnummer óók een instantie is van psp:commentaar: werk dan die instantie bij met de purescript data.
	- anders:
		- maak een instantie van de rol psp:commentaar van waarin de properties psp:tekst en psp:aantalTekstRegels zijn vastgelegd. Leg het volgnummer uit de parser state er ook in vast. 
		- voeg die nieuwe rol dan toe aan de huidigeTekstContext en sla hem op.
		- verhoog de volgnummers van alle rollen die een gelijk of hoger volgnummer hebben.
	ParserState:
	- voeg de rol toe aan gevondenRollen;
	- verhoog het volgnummer.

SECTIE-EXPRESSIE
De sectie-expressie (psp:sectie). Past een Arc parser toe voor elke mogelijk sectie. Levert een purescript datastructuur met daarin de sectienaam en het inline commentaar.
	- zoekt vervolgens in de psp:sectie-rollen van de huidigeTekstContext naar een sectie met dezelfde naam. Elke naam mag maar éénmaal voorkomen!
		- indien gevonden: pas zo nodig volgnummer aan en het inline commentaar.
		- anders: maak een instantie van psp:sectie op basis van de purescript data en voeg toe aan huidigeTekstContext.
		- verhoog de volgnummers van alle rollen die een gelijk of hoger volgnummer hebben.
	ParserState:
		- huidigeRol is de rol die past bij de sectie (b.v. 'intern' -> psp:internalProperty, etc.)
		- verhoog de indentering met één.
		- verhoog het volgnummer
		- voeg de psp:sectie rol toe aan gevondenRollen.

ALS DE HELE TEKST IS VERANDERD
We weten wel de instantie van psp:GepresenteerdContextType (E) die de tekst representeert.
We kunnen daarom de parserState construeren:
ParserState:
	regelnummer = 1 (kolom is 1)
	indentering = 0
	huidigeTekstContext = E
	huidigeContext = psp:context van E
	volgnummer = 1
	gevondenRollen = []

Nu parseren we met een parser die bestaat uit deelparsers voor:
	- tekst-declaratie
	- omhullende-context-declaratie
	- commentaar
	- sectie
De commentaar- en sectie parsers werken de huidigeTekstContext bij. 
De omhullende-context parser kan de displayName van de huidigeContext bijwerken en het bijbehorende inline commentaar van psp:context van de huidigeTekstContext.
De tekst-declaratie parser kan de displayName van de huidigeTekstContext bijwerken en het bijbehorende inline commentaar.

Vervolgens parseren we de rest van de tekst met de volledige parser (uitgaand van dezelfde parser state).

VERANDEREN VAN DISPLAYNAME BIJ EEN WIJZIGING VAN MEERDERE REGELS
Als het regelnummer van een declaratie-expressie niet is gewijzigd (en zijn context evenmin) kan een naamswijziging goed doorgevoerd worden.
Anders niet.

EEN STAP TERUG: META-PARSING
In een parser die is gebouwd als combinatie van deelparsers, bepalen die combinaties op elk moment van ontleden wat geldige expressies zijn. Bijvoorbeeld, een parser voor B gevolgd door A accepteert alleen nog maar een B als hij een A heeft gezien.
Als we een parser op elk moment willen kunnen hervatten, moet ook dié toestand hersteld kunnen worden.
De vraag is dus, als we parser-state herstellen: wat voor expressies zijn toegestaan na de vorige expressie? Daarbij speelt indentering uiteraard een rol.
We kunnen elke expressie verbinden met een element in de parse tree. Die 'parse tree' bestaat uit twee niveaus: de GepresenteerdContextType instanties en de onderliggende CRL instanties (psp:View, psp:Property, psp:Zaak, etc).
De (CRL?) representatie van deze types vormt de basis voor het beantwoorden van de wat-is-de-volgende-expressie vraag.
Meer in het bijzonder wordt dit bepaald door de sectie-expressies en de parserState die daardoor ontstaat (n.l. het aspect 'huidigeRol').

Een parser die die representatie hanteert, noem ik een meta-parser.
Een groot voordeel van zo'n parser is, dat we een concrete parser kunnen maken door een ander type te beschrijven!

WAT IS DE KEUZE?
We hebben 11 soorten expressies (waarbij omhullende context- en context-declaratie-expressie als één gerekend worden) en daarbij kunnen we rol-expressies nog onderscheiden in degene zonder mogelijke binding specificatie, met een referentie en met een lexicaal geneste context.
De secties beperken die keuze. Neem bijvoorbeeld 'views': daarbinnen passen alléén view-expressies (en commentaar en mogelijk import?).
Echter, de 'rollen' sectie beperkt de keuze slechts een beetje, omdat alle zes soorten contexten nog mogelijk zijn. Zouden we de contextualiseringsmatrix kunnen gebruiken, dan daalt het aantal mogelijkheden per situatie nog wat verder.

HERSTEL VAN SECTIE/HUIDIGEROL
In de situatie dat we meerdere regels ontleden, beginnen we met een regel die de omhullende context representeert (en die regel slaan we over, want is per definitie niet veranderd).
In die situatie bouwen we de huidigeRol toestand gewoon op. Daarmee wordt de keuze beperkt (zie hieronder).

In de situatie dat we één regel parseren, hebben we twee gevallen:
	- de regel is al gerepresenteerd;
	- de regel is nieuw. Dan hebben we keuze. Een nieuwe expressie op één regel ontstaat per definitie door een return te tikken en valt dus goed te herkennen. 

Als de regel al is gerepresenteerd, dan weten we precies welke deelparser we nodig hebben.

Als de gebruiker begint aan een nieuwe regel die nog niet bekend is, is er keuze. Maar die keuze kan al beperkt zijn door voorafgaande regels. De simpelste aanpak is om de omhullende context te parseren.

Een zuiniger aanpak gaat als volgt. Bepaal het deel van de AST dat correspondeert met de vorige regel (noem het E), lees het volgnummer daarvan uit en noem dat V. Bepaal de context van E, noem die C. Doorzoek de rollen van C (een instantie van GepresenteerdContextType) vanaf V met telkens een kleiner volgnummer totdat je een sectie vindt. Die sectie bepaalt het soort expressie als de gebruiker een declaratie gaat intikken. Behalve dat type zijn natuurlijk ook een commentaar, sectie en import mogelijk.

Dit aspect van de parserState vormt dus geen speciaal probleem.

SECTIES REVISITED
Ik zou de contextualiseringsmatrix kunnen representeren in de CRL representatie van Domein, Partij, enz. door voor elk soort context een aparte rol te definiëren: domeinInContext, partijInContext, enz. De definitie van b.v. Zaak zou dan kunnen luiden:

	psp:Context psp:Zaak
		psp:rolInContext => psp:externalProperty
		psp:rolInContext => psp:internalProperty
		psp:rolInContext => psp:actieInContext
		psp:rolInContext => psp:rolInContext
		psp:rolInContext => psp:zaakInContext
		psp:rolInContext => psp:activiteitInContext
		psp:rolInContext => psp:toestandInContext

Aan de mogelijke rollen in een Zaak kun je aflezen welke andere contexten in een Zaak genest kunnen worden. psp:rolInContext wordt dan gereserveerd voor echte rollen.

Deze mogelijke rollen corresponderen dan óók met evenzovele mogelijke secties in een Zaak-beschrijving in Arc: zaak, activiteit en toestand. Met deze uitbreiding bepalen secties de mogelijke declaratie-expressies dus volledig.

LEXICAAL GENESTE CONTEXTTYPEN REVISITED
In CRL is een naam altijd gescoped binnen een context. In ARC hebben we nu ook scoping naar rolnamen toegelaten. Dat kon wel eens een verkeerd idee zijn. Voorbeeld:

	Zaak Aangifte heeft -- Dit commentaar staat op de regel die Aangifte declareert.
		rollen
			Start (Functioneel) gevuld door
				Activiteit Intake heeft
					rollen
						Uitvoerder (Functioneel) gevuld door Verbalisant

Hier is de volledige naam van Intake: pol:Aangifte$Start$Intake. Maar hier:

	Zaak Aangifte heeft -- Dit commentaar staat op de regel die Aangifte declareert.
		rollen
			Start (Functioneel) gevuld door Intake
		activiteiten
			Intake heeft
				rollen
					Uitvoerder (Functioneel) gevuld door Verbalisant

is de volledige naam van Intake: pol:Aangifte$Intake.
Scoping van properties naar rollen is OK. Maar scoping van de mogelijke binding van een rol naar die rol zelf m.i. niet.

We kunnen dat vermijden met nieuwe secties, zoals boven geïntroduceerd. Dat betekent dat we op CRL niveau activiteit-typen van een context-type moeten representeren naar voorbeeld van rollen, dus met een property zoals rolInContext. Casu quo: activiteitInContext.

NAMEN QUALIFICEREN, MAAR NIET MET PREFIXES OF SEGMENTEN
In plaats van een prefix zouden we deze syntax kunnen gebruiken:

	Intake van pol:Aangifte

In effect vermijden we hier een segment: pol:Aangifte$Intake.

Het voordeel hiervan is dat je geen import expressie nodig hebt. Het nadeel is natuurlijk dat je het bij elk gebruik moet herhalen.