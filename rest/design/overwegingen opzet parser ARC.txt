OVERWEGINGEN OPZET PARSER ARC
De parser moet incrementeel kunnen werken. Daarmee bedoel ik dat hij, gegeven een AST en een aantal veranderde tekstregels, de AST moet kunnen bijwerken.

We moeten dus in staat zijn om
	- de veranderde regels te relateren aan de juiste onderdelen van de AST;
	- de juiste deelparser te kiezen om toe te passen op de veranderde regels
	- de toestand van de parser zoals die gold toen de oorspronkelijke regels werden ontleed, te herstellen.

De tussenrepresentatie noem ik vanaf nu ARC-AST.

OPZET VAN DE PARSER
Ik ga uit van een parser-state waarin opgeslagen:
	- huidigeContext
	- huidigeRol
OPEN VRAAG: als we de indentering opslaan, kunnen we dan vermijden in de tekst te zoeken naar de omhullende expressie?
Contexten (en rollen) die door de parser geconstrueerd worden uit tekst, worden toegevoegd aan de huidigeContext als binding van een instantie van de huidige rol.
De parser zal volgens het onderstaande patroon gebouwd worden:
	arc-regel-parser = do
		...
		vervolg-op-arc-regel-parser
	
	vervolg-op-arc-regel-parser = do
		vervolg1 <|> vervolg2 ...

Hierdoor kan elke deelparser recursief een expressie ontleden in onderdelen, terwijl voor elk type expressie ook één parser beschikbaar is. Deze kunnen we dan incrementeel inzetten vanaf een regel waarvan we weten dat hij niet veranderd is en waarvan we het type expressie kennen. Bovendien hebben we een parser voor de sub-expressies van een willekeurige expressie.

Het is handig om functies te maken die patroonmatig contexten en rollen maken. Bijvoorbeeld:
createContext :: Type -> Name -> BuitenRolId
en:
createContextIn :: Type -> Name -> Unit
waarbij de huidigeContext en huidigeRol uit de parser state worden gebruikt om de aangemaakte context te binden.
En zo ook:
createRolIn :: ID -> Unit

SELECTIE, COMMENTAAR, ENZOVOORT
De kern van de parser ontleed de 'zuivere' ARC tekst. Daaromheen bouwen we een parser die commentaar verwerkt, een registratie maakt van de selectie van contexten en rollen uit de onderliggende representatie die in de tekst (of in het diagram) voorkomen, en extra informatie zoals positie op het scherm, volgnummer binnen de omhullende context, of een subexpressie ingevouwen is of niet, enz.
Deze omhullende parser wordt eerst aangeroepen. Hij vangt het commentaar op regels voorafgaand aan de ARC-expressie weg, het commentaar erachter en eventueel commentaar eronder (dat per definitie even ver is ingesprongen). Ook deze parser werkt incrementeel.

INCREMENTEEL ONTLEDEN, VERSCHILLEN DETECTEREN
Een regelparser construeert een rol of context maar slaat die nog niet op.
Elke rol of context wordt gebonden in een rol van de huidige context, maar dat doet de parser niet.
Het is namelijk mogelijk dat de huidigeContext al een rol heeft met een representatie van de zojuist geparseerde regel.
Ook kan de situatie ontstaan dat dezelfde rol of context tweemaal in de tekst genoemd wordt (dit kan door hem tweemaal in te tikken of door een tekst in te plakken waarin een regel voorkomt met dezelfde naam als een al bestaande).
In de textContext bestaat dan al een rol voor die context op een andere positie.


VAN ARC NAAR CRL PER EXPRESSIE
0a. Omhullende context declaratie:
	Omhullende Context is Domein model:Politie$
wordt in CRL:
	Context model:Politie$ als pol:
Tevens wordt in de parser state huidigeContext op model:Politie$ gezet.
Uiteraard hoeft de omhullende context geen Domein te zijn: het moet een context zijn.
Als het Domein niet bestaat, wordt het gemaakt. 
Elke andere context moet al bestaan; het is niet mogelijk om een Partij te maken in een nieuwe tekst, enz.
Deze omhullende context hoeft nooit te worden vergeleken met een parse tree: het is de root van de parse tree. Hij kan dus direct worden opgeslagen, mocht hij nieuw zijn.

0b. Sectie op topniveau in de tekst
	items
wordt in CRL:
	Section psp:item
De parser state verandert: huidigeRol wordt psp:item.
Elk context type kan eigen rollen introduceren voor zijn items. Als de omhullende context een Zaak is, zijn de secties properties, rollen en acties.
De mapping tussen sectie-namen en rol ligt vast in de parser.

1. Context declaratie: 
	Zaak Aangifte heeft
wordt in CRL
	psp:Zaak $Aangifte
en is dus een context en wordt met de huidigeRol (psp:rolInContext) aan de huidigeContext gebonden.
Hier kan createContextIn gebruikt worden.
Als deze zaak al bestaat, verandert de parse tree niet (de zaak wordt niet opgeslagen).
Tevens verandert het de parser state: de huidigeContext wordt deze context.
Uiteraard kunnen ook Partij, Toestand en Activiteit gebruikt worden.

2,3. Sectie:
	properties
	intern
	extern
	rollen
	views
	acties
Deze regels veranderen de parser state:
	- 'properties' in de context van een roldeclaratie introduceert de rol psp:rolProperty als huidigeRol.
	- 'intern' introduceert de rol psp:internalProperty als huidigeRol.
	- 'extern' introduceert de rol psp:externalProperty als huidigeRol.
	- 'rollen' introduceert de rol psp:rolInContext als huidigeRol.
	- 'views' introduceert de rol psp:viewInRol als huidigeRol
	- 'acties' introduceert de rol psp:actieInContext als huidigeRol.

4. Property declaratie:
	urgentie (String, NietVerplicht, Functioneel)
wordt:
	psp:Property $Urgentie
		extern psp:isFunctioneel = true
		extern psp:isVerplicht = false
		extern psp:range = String
Deze context wordt met de huidigeRol (psp:internalProperty, psp:externalProperty of psp:rolProperty) aan de huidigeContext gebonden.
Hier kan createContextIn gebruikt worden.
Als deze context al bestaat, verandert de parse tree niet.

5a. View declaratie:
	Adres met properties
wordt:
	psp:View $Adres
Deze context wordt met de huidigeRol (psp:viewInRol) aan de huidigeContext gebonden.
Tevens wordt deze context de huidige context en psp:propertyReferentie de huidige rol.
Hier kan createContextIn gebruikt worden.
Als deze context al bestaat, verandert de parse tree niet.

5b. Property in View declaratie:
		huisnummer
wordt:
	psp:propertyReferentie => $$huisnummer
Er wordt in de huidige context (een psp:View) een instantie van de huidigeRol (psp:propertyReferentie) aangemaakt, waarvan de binding $$huisnummer is. 
Hier kan createRolIn gebruikt worden.
Als de huidige context al een rol heeft waarvan de binding $$huisnummer is, verandert de parse tree niet.

6a. Rol declaratie:
	UserRol gevuld door Vuller heeft
wordt:
	psp:Rol $<generatedIdentifier>
Hierbij is
	<generatedIdentifier> een in de huidige context unieke naam;
Deze context (de rol met type psp:Rol!) wordt met de huidigeRol (psp:rolInContext) aan de huidigeContext gebonden.
Hier kan createContextIn gebruikt worden.
Als deze context al bestaat, verandert de parse tree niet.

6b. Rol declaratie met verwijzing:
	UserRol gevuld door Persoon
wordt:
	psp:Rol $<generatedIdentifier>
		psp:mogelijkeBinding => <qualification>Persoon
Hierbij is
	<qualification> een namespace die opgezocht moet worden in de lexicale context hiërarchie. D.w.z. we moeten de rol zoeken met de lokale naam Persoon in de dichtsbijzijnde omhullende context. De volledige naam van die rol gebruiken we.

6c. Rol declaratie met verwijzing en naam:
	Verbalisant gevuld door Persoon
Dit geeft hetzelfde resultaat als bij 6a, maar in plaats van de gegenereerde identifier wordt de gegeven naam gebruikt:
	psp:Rol $Verbalisant
		psp:mogelijkeBinding => <qualification>Persoon
Als de parser incrementeel wordt toegepast en de vorige fase 6b was, wordt alleen de localName aangepast.

7. Rol declaratie met ingebedde definitie:
	Start gevuld door
		Activiteit Intake
Dit wordt:
	psp:Rol $Start
		psp:mogelijkeBinding =>
			psp:Activiteit $Intake

8. Actie
	Actor beheert Verbaal
wordt:
	psp:Actie <generatedIdentifier>
		psp:werkwoord => psp:beheert
		psp:lijdendVoorwerp => $$Verbaal
Deze context wordt met de huidigeRol aan de huidigeContext gebonden.
Hier kan createContextIn gebruikt worden.