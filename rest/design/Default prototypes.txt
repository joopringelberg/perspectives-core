DEFAULT PROTOTYPES

1. Geef psp:Context een nieuwe rol: $defaultPrototype. Hij is functioneel en de $mogelijkeBinding is psp:Context.

2. Als de parser een context X maakt waarvan het type psp:Context (of een subtype) is, zoekt hij bij psp:Context (of dat subtype) de binding van $defaultPrototype en bindt die aan de buitenrol van die context X.

3. Dat wil zeggen: tenzij X al een prototype heeft.

Op deze manier verwerft elke Context met type psp:Context een prototype en voldoet daarmee aan de verplichting om een binding aan de rollen binnenRolBeschrijving en buitenRolBeschrijving te geven.

Alléén bij het inlezen van psp:Context zelf ontstaat een probleem, want dan kan de parser nog niet de binding van $defaultPrototype opvragen. Misschien kunnen we dat opvangen door éérst na te gaan of er een prototype is.

Vermoedelijk moet dan wel psp:Context de eerste definitie in perspectives.crl zijn.

Waarom zouden er geen problemen ontstaan voor andere types? De beperking die volgt uit default prototypes is dat een type moet zijn verwerkt voordat er instanties van dat type gemaakt kunnen worden.

De rol $prototype is alleen gedefinieerd voor psp:Context.
De rol $defaultPrototype eveneens.
Dus alleen voor instanties van psp:Context kan een $defaultPrototype worden opgegeven.
Oftewel: voor alle Contexten die psp:Context als type hebben. Direct, of via een aspect.
Laat T zo'n type zijn.
Een instantie van T kan een $prototype krijgen.
T kan zelf een $defaultPrototype krijgen.
T is dus psp:Context, of een type met $aspect => psp:Context.

Dat zijn:
	* psp:Context
	* psp:SimpleValue
	* psp:Actie
	* psp:Werkwoord
	* psp:Zaak
	* psp:Systeem

Dus: ik moet garanderen dat deze zes zijn gedefinieerd voordat een instantie wordt gemaakt. Oftewel, deze vijf moeten eerder in de tekst staan dan hun instanties.

Wat ik óók kan doen is er een nabewerking van maken. Dus als alle contexten zijn gedefinieerd, voeg ik eventueel default prototypes toe. Zo los ik ook het forward reference probleem op voor het buitenRolType, de inverse rolbinding administratie en voor de ?localName syntax.

Het algoritme zou zijn:
1. Voor elke context:
2. Als de context een prototype heeft, doe niets.
3. Anders: lees het $defaultPrototype van het type van de context. Dat is het eerste dat je tegenkomt in de aspect-hierarchie, beginnend bij het type zelf.
4. Indien gevonden: geef de context dat prototype TENZIJ het prototype de context zelf is.
	- vindt de buitenrol van de context
	- bindt de buitenrol aan het prototype.

DEBUG
Dit algoritme geeft psp:Context een prototype, namelijk zijn eigen defaultPrototype. Ik vermoed dat dat leidt tot een lus in de typeDefChecker. 
NEEN. psp:Context krijgt in de tekst al dat prototype.

Louter door aan psp:SimpleValue toe te voegen:

	$defaultPrototype => psp:SimpleValuePrototype

stopt de checker niet meer.

Hypothese: psp:SimpleValuePrototype krijgt zichzelf als prototype en dan ontstaat de lus.
Controleer in de file. Klopt.
Voorkom dit.
Opgelost!