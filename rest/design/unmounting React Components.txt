UNMOUNTING REACT COMPONENTS

Wanneer unmount je een react component? Bijvoorbeeld als een binding verdwijnt en er staat een RolBinding component op het scherm, dan unmount die component.

Maar ook als je een scherm sluit!
Dat is een andere situatie. De gebruiker geeft dan aan dat hij niet langer is geïnteresseerd in de onderliggende query. Dus in de tripleAdministration mag het effectTriple verdwijnen. Dat kan gevolgen hebben in de rest van het netwerk.

De vraag is dus: hoe kan een component via de API aangeven dat 'zijn' effectTriple opgeruimd mag worden?

Dat kan met:

	unsubscribeFromObjects :: Subject -> Predicate -> CorrelationIdentifier -> MonadPerspectives Unit
	
IDENTIFYING THE EFFECT TRIPLE
In pushesObjectsTo wordt het effecttriple opgebouwd, waarbij het vooral gaat om de waarde van 'predicate'.

	predicate tgName <> " ~> " <> effectName

en:
effectName is de naam van het QueryEffect (een NamedFunction), en dat is simpelweg de correlation identifier.

tgName is de naam van de TypedTripleGetter die aan het QueryEffect is gekoppeld.

Het effect dat wordt toegepast, is geconstrueerd met sendResult.

sendResult :: CorrelationIdentifier -> Api.ApiEffect -> PerspectivesEffect String
sendResult corrId pe as = liftEffect $ (unsafeCoerce pe) (Api.convertResponse $ Result corrId as)

In essentie gaat het resultaat (een array van strings) terug met de correlation identifier.

De grote vraag is: is de correlation identifier voldoende om het EffectTriple terug te kunnen vinden? Niet zoals het nu gebeurt, want dan moeten we ook de naam van de TypedTripleGetter hebben die aan het QueryEffect is gekoppeld. Dus:
	* ofwel we moeten die naam naar de GUI sturen;
	* ofwel we moeten het effectTriple een ander predicate geven.

Kan de correlation Identifier een voldoende predicate naam zijn? Een triple wordt geïdentificeerd door de combinatie van zijn subject, en een predicate. De vraag is dus: kan dezelfde correlation identifier meerdere keren met hetzelfde subject worden gecombineerd (en willen we ze uit elkaar kunnen houden, b.v. apart kunnen weggooien)?

Het antwoord luidt: nee. Immers, een call door de API betreft altijd een subject, en een predicate. Nemen we even aan dat dit 'predicate' in het RequestRecord hetzelfde betekent als 'predicate' in een Triple. Dan betreft een RequestRecord precies één Triple en dat wordt geïdentificeerd door het subject en het predicate.
Maar het wordt óók geïdentificeerd door de correlation identifier! Die wordt namelijk per call door de ApiProxy aangemaakt.

Rest ons aan te tonen dat 'predicate' in het RequestRecord correspondeert met 'predicate' in het Triple, in alle gevallen dat een QueryEffect aan zo'n Triple wordt gekoppeld.

Ik zie drie patronen in de PerspectivesAPI.
1. het 'predicate' van het RequestRecord is inderdaad gelijk aan dat van het gemaakte Triple, 
2. 'predicate' van het RequestRecord wordt niet gebruikt, maar in dispatchOnRequest wordt *bij een bepaald RequestType altijd dezelfde query gebruikt, als predicate. 
3. er wordt geen Triple gekoppeld aan een Effect (dat is zo bij alle calls die een zij-effect op de theory hebben, zoals CreateRol).

Kortom, ik kan veilig de correlation identifier gebruiken als het predicate van het EffectTriple.

Nu moeten we bij unmounten simpelweg een Unsubscribe doen met het subject en met de Correlation Identifier.
