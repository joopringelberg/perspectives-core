CONTEXTROL REVISITED

CENTRALE IDEE
1. De binding van een ContextRol is beperkt tot andere ContextRollen en tot de ExterneRol.
2. RolInContext bindt alléén aan RolInContext.
3. InterneRol bindt alléén aan ExterneRol.
4. ExterneRol bindt alléén aan ExterneRol.

5. Het verschil is dat we nu Rol hebben en die bindt aan Rol en aan Context.

6. De TypeDefChecker moet dan in staat zijn om definities van deze rollen van elkaar te onderscheiden. 
7. Dat kan bijvoorbeeld door subtypes van Rol te definiëren in Perspectives.crl. Bijvoorbeeld zo:

	psp:Context psp:ContextRol
		$aspect => psp:Rol

8. Je test dan of een type een ContextRol is met: 'hasType "psp:ContextRol"'

DIT KLOPT, maar het geldt alleen voor Context en zijn subtype (dingen die Context als Aspect hebben).
Dus: alleen waar mogelijkeBinding als waarde de buitenRol heeft van een Context die Context als Aspect heeft, moeten we die waarde vervangen (door de buitenRol van BuitenRolBeschrijving van de Context).

IMPLEMENTATIE IN DE PARSER
1. De mogelijkeBinding van een ContextRol moet dan de *beschrijving* van de ExterneRol van een Context zijn. 
2. Hoewel we een schema voor naamgeving van dergelijke beschrijvingen hebben (en merk op dat het zelf natuurlijk contexten zijn, als types!), is het niet eenvoudig om bij het schrijven van een model te weten welke beschrijving je voor een bepaalde Context moet hebben, vanwege het gebruik van prototypes.
3. Daarom is het belangrijk dat het systeem zelf de juiste ExterneRolBeschrijving opzoekt.
4. Dat kan niet tijdens het parseren, vanwege voorwaartse referentie. Het kan wel in een nabewerkingsslag.
5. Die slag betreft alle contexten wier type ContextRol is. De mogelijkeBinding van een ContextRol moet tijdens die slag vervangen worden door de ExterneRolBeschrijving van zijn actuele waarde.
6. De ExterneRolBeschrijving van een Context vindt je door de rol $buitenRolBeschrijving te nemen. Dat moet je doen met een functie die prototypes in overweging neemt.

CONSEQUENTIES VOOR EEN MODEL
1. Als je een rol definieert, moet je aangeven of het een RolinContext is, een ContextRol, een BuitenRol of een BinnenRol - nu gebruik je altijd gewoon Rol.
2. We krijgen bij Context naast $rolInContext óók $contextRol (we hebben als $binnenRolBeschrijving en $buitenRolBeschrijving).

WAAROM ZOU JE HET DOEN?
In de huidige code is op tal van plaatsen een gevalsonderscheiding aanwezig tussen Context en Rol. Ik begrijp dat niet voldoende, heb geen overzicht en vrees dat het niet volledig of zelfs niet correct is. De hoop is dat ik met deze slag daar helderheid in kan brengen.

WAAR SPEELT DAT IN DE CODE?

Opmerkingen nav onderzoek
1. moet in TypeDefChecker.checkRolDef niet een controle op mogelijkeBinding worden opgenomen?

2. Ik controleer of de mogelijkeBinding van een RolDef wel een subtype is van de mogelijkeBinding van al zijn AspectRollen (TypeDefChecker.mogelijkeBindingSubsumedByAspect, maakt gebruik van ModelBasedStringTripleGetters.isSubsumedOnEachRolTelescopeOf)

3. In TypeDefChecker.compareRolInstanceToDefinition onderscheiden we ContextRol van RolInContext. Deze test is onderdeel van checksForEachContext. We toetsen elke rol-instance, d.w.z. controleren of hij voldoet aan zijn definitie. Dat *MOET* dezelfde controle zijn als TypeChecker.checkBinding.

4. TypeDefChecker.checkBindingOfContextRol en TypeDefChecker.checkBindingOfRolInContext implementeren de rolbinding test op type niveau.

5. Zij maken gebruik van ModelBasedStringTripleGetters.hasContextTypeOnEachRolTelescopeOf en ModelBasedStringTripleGetters.hasRolTypeOnEachRolTelescopeOf.

6. TypeChecker.checkBinding controleert of het type van de rol waaraan gebonden wordt, een (super)type is van de rolinstantie die gebonden zou worden. 
Ook hier wordt onderscheid gemaakt naar ContextRol en RolInContext. Ook hier wordt gebruik gemaakt van ModelBasedStringTripleGetters.hasContextTypeOnEachRolTelescopeOf en ModelBasedStringTripleGetters.hasRolTypeOnEachRolTelescopeOf.

VERGELIJK VAN TYPECHECKER.CHECKBINDING EN TYPEDEFCHECKER.COMPAREROLINSTANCETODEFINITION
Zoals hierboven opgemerkt moet de rolbinding-check van beiden semantisch hetzelfde zijn.
checkBinding heeft als parameters:
	* het RolType van de rolinstantie waaraan we willen binden;
	* de rolinstantie die we willen binden.

compareRolInstanceToDefinition heeft als parameter
	* de instantie van een RolType
	* de binding van die instantie ('bnd')

Deze twee parametersets zijn dus vergelijkbaar; maar bij checkBinding is de binding nog niet tot stand gekomen.

Afbeelding:
checkBinding.typeOfRolToBindTo === compareRolInstanceToDefinition.rolType
checkBinding.valueToBind === compareRolInstanceToDefinition.bnd

Dan volgt een GEVALSONDERSCHEIDING.

	* checkBinding test of de mogelijkeBinding van het RolType een subtype is van Rol.

	* compareRolInstanceToDefinition maakt gebruik van DataTypeObjectGetters.isBuitenRol (een functie die de *naam* van de binding gebruikt om vast te stellen of het type van 'bnd' een BuitenRolBeschrijving is.

Opmerkelijk dus dat checkBinding het RolType onderzoekt, en compareRolInstanceToDefinition de binding, om vast te stellen of we te maken hebben met een ContextRol of een RolInContext.

Ik heb bij compareRolInstanceToDefinition een denkfout gemaakt. Het gaat er hier niet om de definitie te controleren, maar de instantie. We mogen dus, nee *moeten* dus het RolType als leidend beschouwen. Door de binding als uitgangspunt te nemen, vergis ik me. Dat past bij controle van het type, als we proberen vast te stellen of we het over een ContextRol of een RolInContext hebben.

Dan de CONTEXTROL test.
In checkBinding.checkBindingOfContextRol neem ik de context van de rolinstantie. Daarbij ga ik ervan uit dat een ContextRol altijd aan een BuitenRol gebonden wordt. Dat is niet juist; het kan ook een ContextRol zijn.
Ik test dan of de mogelijkeBinding van het RolType een (super)type is van die context.

In TypeDefChecker.checkBindingOfContextRol kijk ik of de mogelijkeBinding van het RolType een (super)type is van de ROLBINDINGDEF van de rolinstantie. Van de rolinstantie is vastgesteld dat het een buitenRol is. De rolBindingDef is gedefinieerd als context na binding. Omdat we een ContextRol hebben, levert dat dus de context-instantie op die is gebonden.

Beide methoden (context, en binding >-> context) geven hetzelfde resultaat op een BuitenRol instantie.

De tests zijn dus hetzelfde.

TEKORTKOMINGEN
1. Als de binding ook weer een ContextRol is, falen beide tests.
	* in TypeDefChecker.compareRolInstanceToDefinition wordt dan bij de gevalsonderscheiding ten onrechte geconcludeerd dat we met een RolInContext te maken hebben.
	* In TypeChecker.checkBinding vindt de gevalsonderscheiding op typeniveau plaats (op typeOfRolToBindTo). Die delegeert dus ook een ContextRol gebonden aan een ContextRol naar checkBindingOfContextRol. Maar daar wordt ten onrechte aangenomen dat het een BuitenRol is, zodat de context van de RolInContext wordt getoetst aan het type. Dat is semantisch onjuist.

2. TypeDefChecker.compareRolInstanceToDefinition delegeert nooit naar checkBindingOfRolInContext.

3. TypeDefChecker.compareRolInstanceToDefinition doet geen goede gevalsonderscheiding; TypeChecker.checkBinding wèl.


CONCLUSIES
1. We moeten in TypeChecker.checkBinding onderscheid maken tussen ContextRol, RolInContext en BuitenRol.
2. We hoeven nooit het geval BinnenRol te toetsen; die wordt alleen in de parser aangemaakt, of in code, en daar doen we de binding goed.
3. We kunnen (het binding-toets gedeelte van) TypeDefChecker.compareRolInstanceToDefinition vervangen door TypeChecker.checkBinding.


TE ONDERZOEKEN
1. Hoe verhouden TypeDefChecker.checksForEachContext en de TypeChecker zich?
2. Waar worden functies van TypeChecker gebruikt?
3. Welke functies van de API worden getroffen door het onderscheid tussen RolInContext en ContextRol?
	Dat valt mee. We kunnen typeonderscheiding doen waar nodig.
4. Kunnen we de modellering aanpassen zonder de primaire representatie aan te passen?
	Ik denk het wel.

PRIMAIRE REPRESENTATIE AANPASSEN?
1. In PerspectContext kunnen we ContextRollen en RollenInContext van elkaar onderscheiden.
2. Moeten we dan ook bij de inverse relatie dat onderscheid maken?
3. Alle functies die nu iets met alle rollen van een context doen, moeten dan worden aangepast (of we moeten een functionele abstractie maken).
4. Het is dan niet langer nodig, noch mogelijk, om 'een rol' op te vragen en dan gevalsonderscheiding te doen.
5. Is het zinvol om PerspectRol een typeveld te geven? Het kan een kwestie van efficiency zijn. In plaats van het type van een rol te nemen en dan te bepalen of het een subtype is van RolInContext, kunnen we direct het typeveld aflezen.

GEVONDEN CONSEQUENTIES VAN AANPASSING VAN DE PRIMAIRE REPRESENTATIE
1. In BasicConstructors.constructRol moeten we gevalsonderscheiding op het type doen om vast te stellen welke waarde het roltypeveld van de nieuwe rol moet hebben.
2. in BasicConstructors.constructAnotherRol moeten we gevalsonderscheiding doen om het juiste volgnummer te bepalen.
3. De Parser moet het roltypeveld invullen. Dat moet waarschijnlijk in een nabewerkingsslag.
4. In Perspectives.ObjectGetterConstructors krijgen de functies die een RolInContext vs een ContextRol opzoeken, een nieuwe implementatie.
5. Actions.addRol wordt gesplitst in twee versies. Idem voor removeRol en setRol
