MCLOSURE

mclosure is een recursieve functie die het fixed point (closure) berekent van een SingleGetter.
We willen deze functie zodanig schrijven dat een theorieverandering op de SingleGetter automatisch tot een nieuw fixpoint leidt.

Situatie:
De functie close laat zien hoe een patroon van locaties opgebouwd kan worden dat tot het juiste updategedrag leidt. NB: ONGETEST!

	close :: forall a.
	  (Location (Maybe a) -> Location (Maybe a))
	  -> Location (Maybe a)
	  -> Location (Array a)
	close f loca = (maybe id Arr.cons) <$> loca <*> (bind loca h)
	  where
		h :: Maybe a -> Location (Array a)
		h (Just _) = close f (f loca)
		h Nothing = locate []

De essentie van deze functie is dat het functionele deel waarin besloten wordt tot recursie of beeindiging, met bind de verbinding wordt tussen de input waarde Location (Maybe a) en het resultaat Location (Array a).
close termineert echter niet als de SingleGetter idempotent is. Dat geldt b.v. voor rdf:type, want: <rdfs:Class: rdf:type rdfs:Class>.

Een verbeterde versie accumuleert óók de waarden in een extra parameter:

	closeWithAcc :: forall a. Eq a =>
	  (Location (Maybe a) -> Location (Maybe a))
	  -> Array a
	  -> Location (Maybe a)
	  -> Location (Array a)
	closeWithAcc f acc loca = (maybe id Arr.cons) <$> loca <*> (bind loca h)
	  where
		h :: Maybe a -> Location (Array a)
		h (Just a) =
		  let
			n = f loca
			acc' = (maybe id Arr.cons) (locationValue loca) acc
		  in case locationValue n of
			Nothing -> locate []
			(Just next) ->
			  case Arr.elemIndex next acc' of
				Nothing -> closeWithAcc f acc' n
				otherwise -> locate []
		h Nothing = locate []

Hier wordt het besluit tot recursie mede genomen op basis van de test of de volgende applicatie van f een resultaat oplevert dat al eerder geaccumuleerd werd. Merk op dat het accumuleren dus tweemaal gebeurt: eenmaal met DT in locaties (van links naar rechts), éénmaal zonder (van rechts naar links).

De volgende stap is om uit deze functie er één af te leiden die een SingleGetter accepteert, d.w.z. een functie die Location (Maybe Resource) in een monad oplevert.

Alternatief: maak eerst een versie van close die een SingleGetter accepteert. Die is minder bruikbaar maar omdat close simpeler is, is het misschien een goede tussenstap naar het inwerken van de monad.