EEN LOOP IN THEORYCHANGE

AANPAK
Ik ga proberen om bij het aanleggen van dependencies al cycles te detecteren.
Dat moet in: TripleAdministration.addDependency

Bouw een depth first search in om cycles te vinden.

					depedentRef
			|							/\
			|							|
		support						dependent
			|							|
			\/							|
					supportingRef


Controleer of de nieuwe dependent leidt tot cycles. Dus: volg de dependent depth first en meld een cycle als je de supportingRef weer tegenkomt.

Ik controleer alleen op de supportingRef.

Ik wil een volledige cycle. Dus: een pad meeslepen en direct melden.
Hoe meld je? Foutmelding, of een state opbouwen. Maar we zitten in Effect.
Is Effect een instantie van MonadError?
Neen.
Ik kan alles optillen naar Aff en dan kan ik wel een Error melden.

addDependency wordt gebruikt in:
	* addToTripleIndex
		gebruikt in TripleGetterFromObjectGetter.constructTripleGetterFromEffectExpression CYCLE DETECTION TOEGEVOEGD.
	* registerTriple
		gebruikt in QueryEffect.pushesObjectsTo

BINGO:
Error: Cycle in dependencies: [
	{"model:User$test1_binnenRol", "model:TestBotActie$Test$binnenRolBeschrijving$trigger"},
	{"model:User$test1_binnenRol", "model:TestBotActie$Test$binnenRolBeschrijving$trigger"}]

WAT IS DIT?
[
{"model:User$test1", "(equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1))"},
{"model:User$test1", "(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2)"}
]
het zijn twee TripleRefs. 
Beiden hebben u:test1 als subject.
De eerste heeft $propsEqual als predicaat.
De tweede heeft $v2 als predicaat.

Ik weet het alweer! Het is de waarde van member 'recomputed' van PerspectivesState. Oftewel, als een triple herberekend wordt, wordt zijn TripleRef in 'recomputed' geschreven.

In de test komt assertEqualWithPropagation tweemaal voor:
	* De eerste keer is als de botActie wordt toegepast;

[
{"model:User$test1", "(equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1))"},
{"model:User$test1", "(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2)"}
]

	* de tweede keer is als property $v1 de waarde "noot" krijgt (dus overschreven wordt).
	
[
{"model:User$test1", "(equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1))"},
{"model:User$test1", "(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)"}
]

Het eerste triple is $propsEqual
Het tweede triple is de support daarvan, van de binnenRol naar $v1
Dat klopt.
$v1 veranderde. Daardoor veranderde binnenRol >-> $v1. En vervolgens veranderde $propsEqual.

Maar daar stopt het, terwijl de not (de conditie) óók verandert.

Kan ik niet een effect aan deze triples hangen? Een effect dat naar de console schrijft? Dan hoef ik alleen maar een waarde te veranderen om op de console te zien wat er verandert.
De test op $propsEqual en die op $conditie wordt namelijk uitgevoerd door een nieuwe query op te bouwen. Goed mogelijk dat hierdoor een nieuwe berekening uitgevoerd wordt.

====================
Ik wil weten of de dependencies goed opbouwen.
Dus ik zou systematisch de functies kunnen gebruiken die een dependency aanleggen, en dan controleren of het ook goed gegaan is.
1. Waar worden dependencies aangelegd?
	-> waar worden supports bepaald?
	-> waar worden supports in dependencies omgezet? Die laatste vraag heb ik hierboven beantwoord.
2. De hoofdvraag is dus: waar worden supports bepaald? Afgezien van registerTriple (dat alleen in QueryEffect.pushesObjectsTo wordt gebruikt), in alle voorkomens van addToTripleIndex

registerTriple
	QueryEffect.pushesObjectsTo			- OK
addToTripleIndex
	- constructTripleGetterFromEffectExpression
		- constructTripleGetter, alias trackedAs. GECONTROLEERD
			Wordt 57 keer gebruikt.
		- QueryCombinator.contains 				VERVANGEN
		- QueryCombinator.containsMatching 		VERVANGEN
		- QueryCombinator.containedIn 			VERVANGEN
		- QueryCombinator.not 					VERVANGEN
		- QueryCombinator.not' 					VERVANGEN
	- constructTripleGetterWithArbitrarySupport
		- ComputedTripleGetters.modellenM
		- ComputedTripleGetters.parserMessagesM
		- ComputedTripleGetters.syntacticStateM
		- ComputedTripleGetters.typeCheckerMessagesM
		- ComputedTripleGetters.semanticStateM
	- runMonadPerspectivesQuery. Maar hier gaat het om het start-triple en dat heeft geen dependencies.
	
QUERYCOMBINATORS.NOT
'not' is opgebouwd met constructTripleGetterFromEffectExpression. Maar die laatste functie geeft nu geen supports aan het triple dat met addToTripleIndex wordt geregistreerd. Dat heb ik gedaan omdat er ergens een cycle ontstond.

ANALYSE
trackedAs wordt toegepast op een ObjectsGetter. De berekening in zo'n ObjectsGetter bouwt geen dependencies op en berust niet op dependencies. Het triple dat in constructTripleGetterFromEffectExpression wordt opgebouwd, heeft dan ook geen support.

Maar dat geldt niet voor QueryCombinator.not en de anderen in QueryCombinator. Daar gaat een TypedTripleGetter berekening aan vooraf, die wèl een support vormt voor de berekening van het triple dat de negatie representeert.

[{"model:User$test1", "((equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)) ~> propsEqualEffect)"},

{"model:User$test1", "(equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1))"},

{"model:User$test1", "(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)"}]



[
{"model:User$test1", "model:Perspectives$binnenRol"},
{"model:User$test1_binnenRol", "model:TestBotActie$Test$binnenRolBeschrijving$v1"}
]


[
<model:User$test1 - ((equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)) ~> propsEqualEffect)>,

<model:User$test1 - (equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1))>,

<model:User$test1 - (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)>]


TO DO
1. Stel vast dat Dependencies worden toegevoegd, niet overschreven.
2. Stel vast dat de queue goed wordt gesorteerd en dat er geen dingen uit vallen.
3. Waarom geeft het effect op $propsEqual tweemaal "true"?
4. Waarom zie ik geen herberekening van de not op propsEqual?
5. Waarom wordt de condition wel uitgerekend op de juiste waarde maar zie ik geen propagation?
6. Is er wel triple administratie na het uitrekenen en toepassen van de botactie, voor deze twee?

VOORLOPIGE DIAGNOSE
De combinatoren `followedBy` en `before` gooien roet in het eten. Ze zijn puur bedoeld als tegenhangers van 'wrap' en 'unwrap', d.w.z. om newtypes te veranderen. `followdBy` maakt een nieuw triple, waarvan het object en de getter anders getypeerd zijn. Dit triple wordt niet aan de TripleAdministratie toegevoegd. Ik noem het een PhantomTriple, en het triple waarop het is gebaseerd het Original.

Weliswaar heeft een PhantomTriple dezelfde supports als zijn Original, maar die supports hebben het niet als dependency - omdat ik het niet aan de TripleAdministratie heb toegevoegd.

Het gevolg daarvan is dat het PhantomTriple niet wordt geactualiseerd bij TheoryPropagation.

Wat is daarvan het gevolg? Het PhantomTriple heeft dezelfde identificatie als het Original (subject-predicate).

Een triple dat op zijn beurt weer op zo'n PhantomTriple is gebaseerd, gebruikt een TripleRef om die relatie vast te leggen. Bij het opzoeken van de TripleRef komt het Original tevoorschijn - want dat is geregistreerd.
Kortom, het lijkt me dat de progagatie goed moet gaan.


Dit zijn de triples met subject $test1. Het klopt allemaal. We zien ook het triple voor het predicaat met 'not' en met 'not not'. Zelfs de object waarden kloppen precies.

(Just (fromFoldable 
[
(Tuple "model:Perspectives$start" 
	<"model:User$test1";"model:Perspectives$start";["model:User$test1"]>),

(Tuple "model:Perspectives$binnenRol" 
	<"model:User$test1";"model:Perspectives$binnenRol";["model:User$test1_binnenRol"]>),

(Tuple "(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)" 
	<"model:User$test1";"(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)";["aap"]>),

(Tuple "(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$trigger)" 
	<"model:User$test1";"(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$trigger)";["true"]>),

(Tuple "model:Perspectives$not_(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$trigger)" 
	<"model:User$test1";"model:Perspectives$not_(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$trigger)";["false"]>),

(Tuple "model:Perspectives$not_model:Perspectives$not_(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$trigger)" 
	<"model:User$test1";"model:Perspectives$not_model:Perspectives$not_(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$trigger)";["true"]>)

]))

EQUAL
<model:User$test1 - 
	(equal 
		(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1) 
		(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2))>,

<model:User$test1 - 
	(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2)>


NOT EQUAL: RECOMPUTED TRIPLES
[
<model:User$test1 - model:Perspectives$not_(equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2))>,

<model:User$test1 - (equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2))>,

<model:User$test1 - (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2)>]

Het triple dat "not (equal $v1 $v2)" representeert, is wel degelijk herberekend. En ook als laatste.

De triple administratie voor $test1
(Just (fromFoldable [
(Tuple "model:Perspectives$start" 
	<"model:User$test1";"model:Perspectives$start";["model:User$test1"]>),


(Tuple "model:Perspectives$binnenRol" 
	<"model:User$test1";"model:Perspectives$binnenRol";["model:User$test1_binnenRol"]>),

(Tuple "(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)" 
	<"model:User$test1";"(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1)";["aap"]>),

(Tuple "(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2)" 	
	<"model:User$test1";"(model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2)";["aap"]>),

(Tuple "(equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2))" 
	<"model:User$test1";"(equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2))";["true"]>),

(Tuple "model:Perspectives$not_(equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2))" 
	<"model:User$test1";"model:Perspectives$not_(equal (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v1) (model:Perspectives$binnenRol >-> model:TestBotActie$Test$binnenRolBeschrijving$v2))";["true"]>)]))

INDERDAAD heeft het triple "not (equal $v1 $v2)" de waarheidswaarde "true" terwijl het "false" had moeten zijn.

Het is dus herberekend, maar heeft de verkeerde waarde. Maar ik heb in andere tests 'not' prima zien functioneren.
Wat is er aan de hand?









