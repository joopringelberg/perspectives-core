IMPLEMENTATIE VAN CONTEXTROL/ROLINCONTEXT IN DE PARSER
Een Rol kan alleen gebonden zijn aan een Rol. Dat principe huldigen we door in de Parser, als in de tekst een Context genoemd is, de buitenRol van die Context te binden.

Maar, dat is een implementatie op het niveau van instanties.

Cor verbindt in Perspectives de ExterneRol van een Context met een ContextRol. Maar die ExterneRol is de *definitie van de rol die de context representeert*. 

Dat is een implementatie op het niveau van types.


HUIDIGE SITUATIE
1. Een Rol heeft als binding de buitenRol van de Context die in de tekst is gegeven.
2. De binding wordt vastgelegd in PerspectRol in de functie roleBinding'.
3. De waarde van de binding komt uit de parameter p. Relevante bindingen zijn:
	* inlineContextBinding, en dan komt de binding van context en dat is een buitenRol
	* contextBindingByReference en dan is het resultaat een buitenRol


GEWENSTE SITUATIE
De ContextRol krijgt als binding de (buitenrol van) de BuitenRolBeschrijving van de Context die in de tekst is gegeven.
Maar geldt dat voor alle Contexten? 

VIEW EN PROPERTY
In Perspectives gebruikt Cor de 'in' relatie ook om een Property met een View te verbinden. Maar daarbij is uiteraard geen sprake van rollen. 
In CRL is zowel een Property als een View een type, gerepresenteerd met een Context. 
De Context View heeft een ContextRol, $propertyReferentie, die gevuld wordt aan een Property.
Maar hier moeten we uiteraard niet op zoek naar de BuitenRolBeschrijving van de Property. Die is er wel, maar representeert niet de Property in de context van de View.

Wanneer willen we wel die binding met het type van de BuitenRol?

Alleen als de Context die we binden, een type Context representeert. Oftewel, dat zijn instanties als type Context hebben. En dat is bij Property niet het geval. Oftewel, types die Context als Aspect hebben - recursief! Dit is de toets: 

	isOrHasAspect psp:Context

is false voor psp:Property. 

SUBTYPES VAN CONTEXT
* psp:Actie						??
* psp:Werkwoord					??
* psp:Zaak
* psp:Systeem
* psp:Model
* psp:SimpleValue				??

GEEN SUBTYPES VAN CONTEXT
* psp:Rol
* psp:View
* psp:Function
* psp:Sum
* psp:TrustedCluster			??
* psp:assignToRol
* psp:AssignToProperty
* psp:EffectFullFunction
* psp:PerspectivesSysteem		??

AANPASSEN:
* psp:Werkwoord (hoeft Context niet als Aspect te hebben)
* psp:SimpleValue (idem)
* psp:Actie (idem)
* psp:PerspectivesSysteem (moet wel Context als Aspect hebben)
* psp:TrustedCluster (idem)

Ik heb het via het default prototype van Zaak nu zo geregeld dat instanties (dus dingen met type Zaak) automatisch psp:Context als Aspect hebben (tenzij je over hun default prototype heen gaat; dan moet je het zelf regelen).
Hetzelfde geldt voor Systeem en Model.

NIEUWE SITUATIE, SUBTYPES VAN CONTEXT:
SUBTYPES VAN CONTEXT
* psp:Zaak, en al zijn instanties;
* psp:Systeem, en al zijn instanties;
* psp:Model, en al zijn instanties;

Hier komen nog bij:
* Partij
* State
* Activiteit

GEEN SUBTYPE VAN CONTEXT:
* psp:Rol
* psp:View
* psp:Function
* psp:Sum
* psp:assignToRol
* psp:AssignToProperty
* psp:EffectFullFunction
* psp:Actie
* psp:Werkwoord
* psp:SimpleValue

ONDERZOEK
Er zijn vanaf nu twee mogelijkheden voor de mogelijkeBinding rol. Hij is gebonden aan de buitenrol van een
* Context - die een type representeert, in CRL. Voorbeeld: $propertyReferentie bindt aan psp:Property. Het type van zijn buitenrol is de default van Context, psp:ContextPrototype$buitenRolBeschrijving en die heeft geen property definities.
* BuitenRolBeschrijving, die hoort bij een subtType van Context. Voorbeeld: psp:Zaak$modelsInUse bindt aan psp:Model, dus feitelijk aan psp:ModelPrototype$buitenRolBeschrijving en die heeft de property $auteur.

Voor $propertyReferentie staan de externe properties van psp:Property NIET op de roltelescoop.
Voor $modelsInUse staan de externe properties van psp:Model WEL op de roltelescoop (en dat is $auteur).

Hoe pakt dat uit voor propertiesDef?

Passen we propertiesDef toe op $propertyReferentie, dan vinden we allereerst de eigen properties van $propertyReferentie: $volgNummer en $lokaleNaam. Via mogelijkeBinding komen we bij achtereenvolgens psp:Property en psp:SimpleValue. Dat zijn geen definities van Rollen, dus er zijn verder geen properties.

Passen we propertiesDef toe op $modelsInUse, dan vinden we eerst de eigen properties (geen). Via mogelijkeBinding komen we dan bij de beschrijving van de buitenRol van psp:Model, te weten psp:ModelPrototype$buitenRolBeschrijving. Dat is een definitie van een Rol en die heeft een property.

Kortom, de implementatie moet zijn:
* ALS de mogelijkeBinding een Rol oplevert (hasType Rol),
* DAN neem je de propertiesDef van de mogelijkeBinding.

Dat is ten opzichte van de huidige implementatie een minimale verandering. Immers, ik kijk nu of de binding het aspect Context heeft en neem dan de buitenRolBeschrijving.
Wel loop je dan de hele roltelescoop af, nu is het maar één stap.

GEWENSTE SITUATIE, REVISITED
Een ContextRol krijgt als binding de (buitenrol van) de BuitenRolBeschrijving van de Context die in de tekst als waarde is gegeven, **indien die Context psp:Context als Aspect heeft**.
Want dan gaat het over Context types zoals Cor dat in Perspectives hanteert.

Kan de toets isOrHasAspect uitgevoerd worden vóór de voorbewerking voltooid is?
Deze functie is geïmplementeerd in termen van directAspects, en dat is uiteindelijk in termen van getContextRol. Daarin wordt geen gebruik van rolbinding gemaakt.

IMPLEMENTATIE
1. Doorzoek alle ContextRollen;

	dat betekent: doorzoek alle rollen, behandel degenen waarvan het type psp:ContextRol is.
	
2. Als de binding de buitenRol is van een Context die psp:Context als Aspect heeft,

	isOrHasAspect psp:Context
	
3. bepaal dan de beschrijving van de buitenRol van die Context en vervang de binding met de buitenRol van die beschrijving.

	buitenRolBeschrijvingDef

VOLTOOID.