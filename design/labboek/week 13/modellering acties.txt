BESPREKEN MET COR

1. De SubjectRol van een Actie is relationeel (meerdere Rollen kunnen het subject van een Actie zijn). Ik neem echter aan dat de ObjectRol van een Actie functioneel is.

Als dat zo is, dan kan ik beter $object bij psp:Actie modelleren, dan $objectRol bij $rol. Dat is omdat we bij een rol kunnen aangeven of hij functioneel is of niet. Maar als we bij $objectRol aangeven dat hij functioneel is, dan betekent dat dat een Rol maar in één Actie het object kan zijn - en dat is de verkeerde semantiek. We zouden moeten kunnen aangeven bij de $objectRol dat hij //omgekeerd functioneel// is, maar dat kan niet.

Overigens: verwar dit niet met het functioneel of relationeel zijn op instantieniveau van Acties. Een Actie-instantie heeft altijd maar één subject en kan al dan niet meerdere objecten hebben.

Dat is dan wel weer iets dat we bij $object van Actie moeten modelleren: zijn er één, of meerdere objecten? Dat is een te modelleren property bij de rol $object van Actie.

2. Wat er veranderd is in het model:

	a. psp:Systeem werd psp:PerspectivesSysteem
	b. psp:SysteemBot werd psp:Systeem$bot
	c. psp:Rol$objectRol en psp:Rol$subjectRol zijn vervallen, ten gunste van
	d. psp:Actie$subject en psp:Actie$object
	e. psp:Niets

3. psp:Zaak heeft nu een rol $contextBot.
Bij een Actie kan de Rol $subject gebonden worden aan deze rol $contextBot.

REDENERING. Als ik een TaxiRit definieer, maak ik een rol $chauffeur en een rol $passagier. Als ik een TaxiRit instantieer, maak ik instanties aan van deze rollen en vul hen met rollen die de gebruikers representeren.
Als ik die TaxiRit instantieer, kan ik ook een instantie maken van zijn bot. Ik hoef die instantie niet te vullen. Als het systeem dan zoekt naar botacties van die TaxiRit, begint hij bij die bot-instantie en kijkt welke Actie-instanties die bot als $subject hebben.
Maar dat vooronderstelt dat alle (bot)Acties geïnstantieerd zijn. Waarom zou ik dat doen?
Bovendien: je kunt net zo goed op type-niveau opzoeken welke Acties zijn gedefinieerd met de bot als $subject.
Maar dan heb ik wel een specifieke bot-rol-definitie nodig voor de Taxirit. Ik kan die rol-definitie niet laten leveren door een prototype, want dan komen daar alle bot-Acties aan te hangen van alle Contexten die dat prototype gebruiken!
Kortom: als ik op typeniveau wil bekijken welke botacties er zijn moet ik een specifieke bot-rol maken voor elk type context.

Ik kan dat doen met $rolInContext, en dan telkens dezelfde lokale naam gebruiken ('contextBot', bijvoorbeeld).
Ik kan het ook doen met een speciale rol bij Context: $contextBot, bijvoorbeeld. Ik instantieer die rol in de definitie van de Context, maar bindt hem niet.

OPNIEUW
Op enig moment verandert de instantie van een Context. 
Je wilt dan weten: moet ik een automatische actie uitvoeren?
Het antwoord vind je door ermee te beginnen de Acties op te sporen die bij het type van die instantie zijn gedefinieerd, waarvan de $subject Rol gevuld is met de bot van die Context.
(je zou ook een rol $botActies bij de Context kunnen hebben; maar we vinden het mooier om het te vinden via de binding van de $subject Rol van de Actie).
Maar merk op dat we op type-niveau denken. 
De ContextDef moet dus een RolDef hebben voor de bot.
Die RolDef vult de $subject Rol van de ActieDef.
Maar de implicatie hiervan is dat je een aparte bot Rol moet definiëren voor elk type Context met bot acties. Dat is moeizaam.
Gebruik je de bot-rol van een prototype (van b.v. Zaak of Context), dan krijgt die rol alle acties van ContextDefs die hetzelfde prototype hebben gebruikt. Dat is niet selectief genoeg.
Gebruik je de bot-rol van een Aspect, dan geldt hetzelfde.

Of: we gebruiken wèl de bot-rol van een prototype of aspect, maar vinden de bot-acties van een Context door de acties van de context te filteren op de binding van de $subject rol. Dat is minder efficient, want niet rechtstreeks geïndexeerd.

Of: we binden de $subject Rol van Actie niet aan een RolDef, maar aan een Rol (instantie) van de ContextDef. Dat is een hybride aanpak. Je zou dan een ongevulde instantie van psp:Context#contextBot kunnen maken. Maar hoe bind je die aan de $subjectRol van de Actie? Hoe druk je dat uit? Die $subjectRol krijgt dan ook twee mogelijkeBindingen:
	* een RolDef (denk aan chauffeur)
	* een 


TODO
1. vervang psp:Systeem door psp:PerspectivesSysteem in de code. KLAAR
2. Zoek voorkomen van psp:SysteemBot. 							KLAAR
3. Speur alle voorkomens van $objectRol en $subjectRol op en zoek uit hoe veranderd moet worden.
																KLAAR
4. In de tests waar psp:ElkType voorkomt, moet ook een case gemaakt worden voor psp:Niets.
																KLAAR

SNELLE AANTEKENING AAN EINDE VAN DE DAG
1. Ik heb checkBindingOfContextRol geheel herschreven. 	KLAAR
2. Maak nu checkBindingOfRolInContext. 					KLAAR

3. Het blijkt namelijk wel degelijk mogelijk te zijn om in een CRL file een rol direct aan een andere rol te binden (de rollen die je maakt zijn dus niet allemaal ContextRollen!).
4. Dit doe je met de $$ syntax. Zie de binding van $clusterGenoot in systeemInstantie.crl.
5. We kunnen een Context een niet-gebonden instantie van $contextRol geven.
6. Deze rol kunnen we hierdoor gebruiken als $subject van bot-acties.
7. Dan kan de code om die bot-acties te vinden, worden herschreven.
8. Dit alles is het gevolg van het opheffen van $subjectRol (en $objectRol).
9. Zoek uit: hoe wordt het Sum-type van mogelijkeBinding van $subject in Actie?

HOE ZIT HET MET BUITENROLLEN
Een prototype ontstaat door de buitenrol van een context te vullen met de buitenrol van een prototype. Zo is er een roltelescoop waardoor externe properties van prototype beschikbaar worden in de context.

IS DE BUITENROL VAN EEN ASPECT NIET BESCHIKBAAR IN EEN CONTEXT?
Neen. Zie de implementatie van ownRollenDef, waaruit rollenDef volgt, waarop checkAspectOfRolType is gebouwd.
Kan het wel?
Het effect zou zijn dat properties van een BuitenRol van een Aspect beschikbaar zijn in de BuitenRol van de Context.
Daardoor zou PropertyNotDefined niet afgaan als zo'n property op de buitenrol van een instantie van de context gebruikt wordt.
Voor checkPropertyIsDefined gebruiken we de properties die gevonden worden met propertiesDef op de buitenRolBeschrijving. Daar worden aspecten gewoon in meegenomen.
Kortom, checkPropertyIsDefined kan met Aspecten van BuitenRollen omgaan.

Gecontroleerd met een test in modelBasedTripleGetters. Inderdaad levert rollenDef niet de binnen- of buitenRolBeschrijving.

ownRollenDef geeft de waarden van rolInContext voor een definitie, maar daar zit binnen-en buitenRolBeschrijving dus niet bij. M.a.w. de specifiek voor het type van de definitie gedefinieerde rollen ontbreken. Dat is voor alles wat een Context is, dus binnen- en buitenRolBeschrijving.

MOGELIJKEBINDING ERIN BETREKKEN
(IncorrectBinding) In de context 'model:Perspectives$TrustedCluster$RaadpleegtClusterGenoot' is de Rol 'model:Perspectives$TrustedCluster$RaadpleegtClusterGenoot$subject_1' gebonden aan 'model:Perspectives$TrustedCluster$clusterGenoot'(type: 'model:Perspectives$Rol') maar moet worden gebonden aan een instantie van (één van de) type(s) '["model:Perspectives$PerspectivesSysteem$gebruiker","model:Perspectives$Context$contextBot"]'.


model:Perspectives$TrustedCluster$clusterGenoot
	* heeft type model:Perspectives$Rol
	* heeft mogelijkeBinding psp:PerspectivesSysteem$gebruiker

psp:Actie$subject moet gebonden worden aan één van:
	* psp:PerspectivesSysteem$gebruiker
	* psp:Context$contextBot

checkBindingOfContextRol moet dus niet alleen toetsen of het type van $clusterGenoot voorkomt in de toegestane types, maar óók of de mogelijkeBindingen van $clusterGenoot het toestaan.

Hier is een test nodig op compatibiliteit van een type (hier achtereenvolgens $gebruiker, of $contextBot) en een rol-graaf (die van $clusterGenoot). Dat laatste betekent: komt het type langs elk van de paden in de graaf voor? De vertakkingen zijn immers een 'of'.
Het is een soort type-test: "is het hoofd van de rol-graaf óók dit type? D.w.z. komt het langs elk pad in de graaf voor?"

In termen van checkBindingOfContextRol:
	* rolInstance is $subject_1
	* zijn type is psp:Actie$subject
	* de boundValue is $clusterGenoot
	* de waarden van mogelijkeBinding zijn $gebruiker en $contextBot

De toets zou moeten zijn:
	- komt $gebruiker voor in de rolgraaf van $clusterGenoot? (JA)
	- komt $contextBot voor in de rolgraaf van $clusterGenoot? (NEE)

Dus je toetst het type, en elk van de waarden van de mogelijkeBinding van het type van de rolInstantie.
Je toetst deze drie aan de rolgraaf van de boundValue (je vraagt je af: komt één van de drie types voor langs elk pad door de mogelijkeBinding graaf van de boundValue?).

checkBindingOfContextRol is momenteel beperkt tot de toets (isContextTypeOf boundValue) van elk van de waarden van mogelijkeBinding, oftewel, of één van die waarden een type is van boundValue. De rolgraaf van boundValue blijft buiten schot.

Maar dit is zelfs verkeerd. Ik moet kijken of een mogelijkeBinding van het type van de rol compatibel is met de rolgraaf van de boundvalue (inclusief hoofd).

GELUKT! Voor checkBindingOfContextRol.

Moet het ook voor checkBindingOfRolInContext?

DEBUG ISINEACHROLTELESCOPE
Het lijkt me dat als er geen alternatives zijn, 'true' wordt teruggegeven omdat 'all' 'true' teruggeeft op een lege sequence.
Ik heb het aangepast, maar het werkt nog steeds niet.
Test:
* conj
* notEmpty
Beiden werken prima.
Nu weet ik het even niet meer.

MOGELIJKEBINDING
Het probleem blijkt te liggen in mogelijkeBinding.
Er zijn twee implementaties van TripleGetters voor mogelijkeBinding:
* ModelBasedTripleGetters.mogelijkeBinding
* ModelBasedStringTripleGetters.mogelijkeBinding

De eerste wordt getest in Test.ModelBasedTripleGetters en slaagt.
De tweede wordt getest in Test.TripleGetterConstructors, test "isInEachRolTelescope" en faalt.

De laatste wordt gebruikt in ModelBasedStringTripleGetters.isInEachRolTelescope.
Hij is opgebouwd uit:
	- searchInAspectRolesAndPrototypes
	- searchRolInContext
	- genericBinding
	- genericContext

De implementatie van alle members van Class Binding gebruikt genericBinding. Daar kan het probleem niet in zitten.
Het verschil tussen context en genericContext is het wrappen en unwrappen. Daar kan het verschil niet in zitten.

Beide definities van mogelijkeBinding gebruiken StringTripleGetterConstructors.searchRolInContext. 
NEEN, DAT KLOPT NIET!!
Het blijkt dat de StringTripleGetterConstructors versie fout is.
Nu doet de test isInEachRolTelescope het wel!

==========================================================================================
TODO
1. Herschrijf de code om  bot-acties te vinden.
2. Zoek uit: wat wordt het (Sum-)type van mogelijkeBinding van $subject in Actie?
3. Los het probleem op dat 'model:QueryAst$ComputedRolGetter' niet gebonden zou mogen worden aan een rol die als mogelijkeBinding "model:Perspectives$Rol" heeft.
q:RolGetter heeft Aspect psp:Function, maar daar houdt het op.

1. Moeten we onderscheid maken tussen berekende Rollen en Properties?
2. psp:Rol heeft een verplichte Rol, namelijk $mogelijkeBinding, en een verplichte property, namelijk $isFunctioneel. Deze gelden niet voor berekeningen.
3. Op dezelfde wijze hebben we voor psp:Property de verplichte properties $isFunctioneel en $isVerplicht en de verplichte rol $range. Uiteraard gelden deze niet voor de berekende versies.

ROLLEN DIE GEBONDEN WORDEN AAN BEREKENINGEN
Een $rolInContext kunnen we binden aan een berekening.
Dat kan ook voor een $rolProperty.
De TypeDefChecker moet voor een $rolInContext controleren of de berekening een resultaat oplevert dat voldoet aan de $mogelijkeBinding van $rolInContext. Die luidt nu:

				psp:Sum $RolOrContext
					$alternative => psp:Rol
					$alternative => psp:Context

Oftewel, we moeten controleren of de query een Rol of een Context oplevert.

Op dezelfde manier moeten we voor een $rolProperty controleren of de berekening een resultaat oplevert dat voldoet aan de $mogelijkeBinding van $rolProperty. Die luidt nu:

				psp:Sum $FunctionOrProperty
					$alternative => psp:Function
					$alternative => psp:Property

Oftewel, we moeten controleren of de query een Property oplevert (ik negeer psp:Function even).
Samenvattend: we moeten (minstens) in staat zijn om vast te stellen of een query een Context, Rol of Property oplevert.

Gaat het verder?

Ja. Denk aan een berekende rol die gebonden wordt aan een andere rol. Nu moeten we de mogelijkeBinding van deze andere rol vergelijken met het type van de berekende rol. Die mogelijkeBinding kan veel specifiekere types eisen dan Context, Rol of Property.

Kortom, we moeten het type resultaat van een query zo nauwkeurig mogelijk bepalen.

In model:QueryAst hebben we een hele verzameling query-stappen. Hieronder zijn zij gegroepeerd NAAR HET TYPE RESULTAAT dat ze opleveren.

	Properties:
	* q:DataTypeGetter:
		- identity
		- label
	* q:PropertyGetter (geparametriseerd met een property)
	* q:ComputedPropertyGetter (function name will be looked up in the queryCache. Currently, we have modellenM, parserMessagesM, syntacticStateM, typeCheckerMessagesM, semanticStateM, but more may follow and there may even be functions from external modules. We will have to find a way to declare the type of these computed property getters)
	
	Rollen:
	* q:DataTypeGetter:
		- identity, 
		- binding, 
		- buitenRol, 
		- binnenRol,
		- iedereRolInContext, 
	* q:RolGetter
	* q:ComputedRolGetter
	
	Contexten (een querystap kan een Context opleveren, maar dat mag nooit het eindresultaat zijn: dat moet een buitenRol zijn. Merk op dat het type van het resultaat dan toch wel weer die Context is!):
	* q:DataTypeGetter:
		- identity, 
		- rolType
		- context	(niet in implementatie?)
		- typeVanIedereRolInContext
		- contextType
	* q:contains (levert een psp:Boolean en dat is een Context!)

	Alledrie:
	* q:UnaryCombinator
	* q:nAryCombinator
	* q:filter
	* q:Constant
	* q:Variable
	* q:setVariable

TYPEBEREKENING VOOR FUNCTIES DIE PROPERTIES BEREKENEN
Per functie moeten we een recept volgen
	* identity: type van de voorafgaande stap
	* label: het type is psp:String.
	* propertyGetter: type wordt gegeven door de $property rol
	* ComputedPropertyGetter: type moet worden opgezocht in de QueryCache.

TYPEBEREKENING VOOR FUNCTIES DIE ROLLEN BEREKENEN
Per functie moeten we een recept volgen
	* q:DataTypeGetter:
		- identity: type van de voorafgaande stap
		- binding: neem de mogelijkeBinding van het type van de voorafgaande stap
		- buitenRol: elke buitenRol heeft een apart type, namelijk dat van zijn context met de suffix _buitenRolBeschrijving.
		- binnenRol: idem.
		- iedereRolInContext. Ik twijfel over deze functie. Hij is berekenbaar, maar lastig typeerbaar. Of we moeten iets heel algemeens nemen, of we moeten het kleinste gemeenschappelijke Aspect berekenen.
	* q:RolGetter: de binding van de rol $rol
	* q:ComputedRolGetter: zoals bij ComputedPropertyGetter.

TYPEBEREKENING VOOR FUNCTIES DIE CONTEXTEN BEREKENEN
Per functie moeten we een recept volgen
	* q:DataTypeGetter:
		- identity: het type van de voorafgaande stap
		- rolType: het type van de voorafgaande stap
		- context: de definierende context van de voorafgaande stap
		- typeVanIedereRolInContext. Het resultaat van deze functie is een verzameling types. Maar wat is het type daarvan? Misschien moeten we deze functie niet opnemen.
		- contextType: het type van de context.
	* q:Contains: psp:Boolean.

TYPEBEREKENING VAN DE COMBINATOREN
	* q:UnaryCombinator
		- laatste:		type van de voorafgaande stap
		- notEmpty:		psp:Boolean
		- closure:		type van de voorafgaande stap
		- closure':		type van de voorafgaande stap
		- useCache:		type van de voorafgaande stap (controleer implementatie!)
		- ignoreCache	type van de voorafgaande stap (controleer implementatie!)
	* q:nAryCombinator (deze lijst komt uit de queryCompiler maar is m.i. niet compleet)
		* compose		type van het laatste argument
		* concat		type van elk argument
		* and			psp:Boolean
		* or			psp:Boolean
		* implies		psp:Boolean
		* equal			psp:Boolean
	* q:filter: type van het tweede argument
	* q:Constant: type van het argument
	* q:Variabele: op te zoeken in de query omgeving...
	* q:setVariabele: type van het waarde-argument
	
In MonadPerspectivesQueryCompiler houden we een omgeving bij met het type van de vorige stap en een omgeving met gebonden variabelen en hun type.

Iets dergelijks moeten we ook doen in de functie die het type van een query (opnieuw) berekent.

Overigens: we zouden het type-resultaat van de QueryFunctionDescriptionCompiler óók kunnen wegschrijven, samen met de query-beschrijving! Dan hoeven we niet opnieuw de zaak te berekenen ten bate van de typeDefChecker.

Helaas is dit deels begging the question. De QueryFunctionDescriptionCompiler werkt op een AST die het resultaat zal zijn van parsing van een nog niet bestaande query-syntax. De compiler maakt daar een beschrijving in CRL van.
Tot die tijd moet je in CRL die beschrijving met de hand maken. 
Als we de QueryFunctionDescriptionCompiler het type laten bijschrijven, dan betekent dat dat je in CRL dat type er met de hand bij moet schrijven. 
Dat kan, maar de typeDefChecker kan ons dan niet controleren.
Dus: ofwel ik laat die controle achterwege in CRL, of ik maak een functie die het type van een query kan uitrekenen.
Uit overweging van efficiency zou je dan die functie niet willen inzetten op de output van de QueryFunctionDescriptionCompiler, later.

Ik kan natuurlijk EERST het type er met de hand bijschrijven en de typeDefChecker daar gebruik van laten maken. Mocht ik merken dat ik fouten maak, dan kan ik altijd nog de functie maken die het type uitrekent.

Alternatief voor die laatste stap: ontwerp de querysyntax, maak de parser, en neem de nieuwe syntax op in CRL. Dat levert gemak op EN voorkomt fouten.

TODO:
1. Neem het  (resultaat)type van een Functie op in de beschrijving ervan.
2. Baseer de typeDefChecker daarop.
3. (later) Schrijf de query-syntax en de parser, integreer die in de CRL parser.
