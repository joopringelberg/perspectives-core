REPARATIE INVERSE BINDINGEN EN BUITENROLTYPEN

Probleem 1: rolbinding willen we heen en weer representeren. Maar op het moment dat we een RolInstantie vastleggen, kan het zijn dat zijn binding nog niet in de cache beschikbaar is. Dat heeft twee oorzaken:
	a. de beschrijving van de binding (zelf een RolInstantie) is nog niet verwerkt;
	b. de binding komt uit een DomeinFile of is een UserEntiteit die nog asynchroon geladen moet worden.

Probleem 2: het type van een buitenRol moeten we aflezen bij het type van de ContextInstantie waar de buitenRol bij hoort. Maar dat type hoeft nog niet beschikbaar te zijn in de cache.

In de huidige aanpak van probleem 1 leggen we de inverse binding vast in een asynchrone, geforkte berekening.
Ik ga in eerste instantie proberen probleem 2 ook zo aan te pakken.

Een alternatief is om deze twee operaties uit de parser te halen, vervolgens met collectDomeinFile alle rollen te verzamelen en dan voor elk van hen beide operaties (indien toepasselijk) uit te voeren. In deze aanpak hoeft niet geforkt te worden, want oorzaak (a) van het niet in cache beschikbaar zijn speelt dan niet.

TUSSENRESULTAAT
Ik loop vast omdat forkAff gedefineerd is voor Aff, niet voor MonadPerspectives. Ik wil runPerspectives niet toepassen, want dan moet ik telkens een hele nieuwe state meegeven.

==================================== DEBUGGING
"model:User$MijnSysteem$gebruiker_buitenRol"

"model:User$MijnSysteem$zouNietMoeten_buitenRol" heeft nog geen psptype als de foutmelding gegenereerd wordt.
Ik kan de code steppen en alles lijkt goed te gaan.

"model:User$MijnSysteem_buitenRol" evenmin. Ze staan onder elkaar in het array roles in parseAndCache.

PRECIEZE OMSCHRIJVING VAN HET PROBLEEM
Het probleem zit in de rol: "model:User$MijnSysteem$MijnCluster$clusterGenoot_1"
Die heeft als binding: "model:User$MijnSysteem$gebruiker_buitenRol"
En dat klopt niet. Het moet de gebruikersrol van MijnSysteem zijn, dus ik denk: "model:User$MijnSysteem$gebruiker_1"

Het is een gewone rol, dus de binding wordt gemaakt in roleBinding' op regel 341.
De binding wordt geparseerd in roleBindingWithReference, die rust op contextName en daar gaat het om defaultNamespacedContextName. Die pakt de namespace en pelt daar lagen af naar gelang het aantal $-tekens.
Maar dit produceert *nooit* een naam die op _buitenRol eindigt.

1. PROBLEEM. defaultNamespacedContextName concateneert een deel van de namespace met de localName. Maar de tekst bevat de naam van het roltype, niet de id van de rol! Dus: "$$gebruiker", in de context van usr:MijnSysteem$MijnCluster wordt usr:MijnSysteem$gebruiker, terwijl het usr:MijnSysteem$gebruiker_1 moet zijn.
	* merk op dat als een rol niet functioneel is, deze verwijzing onbepaald is. Dus als er meerdere gebruikers van Systeem zouden kunnen zijn, moeten we aangeven welke we dan willen binden.
	* een oplossing zou kunnen zijn dat de modelleur moet aangeven, met een index, welke rol instantie hij wil gebruiken. Dan wordt de tekst: 

sys:Systeem usr:MijnSysteem
	$gebruiker =>
		psp:Context $zouNietMoeten
			extern $voornaam = "Joop"
	$trustedCluster =>
		sys:TrustedCluster $MijnCluster
			$clusterGenoot => $$gebruiker(1)
				$url = "http://localhost"

2. PROBLEEM. roleBindingWithReference leunt op contextName, maar plakt altijd "_buitenRol" achter het resultaat. Dat gaat dus fout als de referentie niet naar een Context, maar naar een RolInContext is!

ANALYSE: zie RELATIEVE NAMEN IN CRL
