TEST BOTACTIE
Modelleer een actie en test compileBotAction. Eenmaal gecompileerd kan je het resulterende netwerk testen door een property te zetten. De actie zou kunnen zijn: kopieer een propertywaarde. Modelleer de test als volgt:
	- maak een context
	- geef die de volgende properties:
		- trigger, een boolean
		- v1 en v2, strings
		- propsEqual: een berekende property die gelijk is aan v1 == v2
	- geef die een Actie
		- met conditie: propsEqual AND trigger
		- met effect: setProperty v1 v2
Test via user interface:
	- Toon v1
	- input v2
	- toon propsEqual
	- input trigger
	- button opnieuw: maakt een instantie van de context met
		- v1 hello
		- v2 world
		- trigger = false



TODO

DONE
1. Maak het model model:TestBotActie
2. Is er een equal operatie?
3. Is er een and operatie?

NIEUWE MODELFILE MAKEN
Het lijkt erop dat de test een bestand, goed gestructureerd, verwacht.
storeDomeinFileInCouchdb zou moeten doorgaan met createDomeinFileInCouchdb voor een nieuwe domeinfile. Maar dan zou er een PUT request moeten komen en die zie ik niet in de Couchdb log. 
Overigens zou modifyDomeinFileInCouchdb óók een PUT moeten doen. Het lijkt er dus op dat het eerder fout gaat, dus al in parseAndCache.


retrieveDomeinFile
	<- checkModel
	<- retrieveContextFromDomein, retrieveRolFromDomein
		<- retrieveFromDomein
			<- fetchPerspectEntiteitFromCouchdb
				<- getPerspectEntiteit
					<- 22 referenties in 6 files
				<- getAVarRepresentingPerspectEntiteit
					<- Perspectives.ContextRoleParser.parseAndCache, sub vultRol

Naast getPerspectEntiteit hebben we ook tryGetPerspectEntiteit, die errors opvangt. Die wordt alleen gebruikt in constructContext.

Wie doet error catching?
getPerspectEntiteit NEE
fetchPerspectEntiteitFromCouchdb NEE
retrieveFromDomein NEE
retrieveContextFromDomein NEE
retrieveRolFromDomein NEE
retrieveDomeinFile NEE

Daar waar je een entiteit ophaalt met getPerspectEntiteit, moet je je er rekenschap van geven dat dat kan mislukken. Althans in sommige situaties. Daar moet je dus tryGetPerspectEntiteit gebruiken.

* Perspectives.BasicActionFunctions.storeDomeinFile
Hier hoeft het niet.

* Perspectives.BasicConstructors.removeFromCache (sub of constructContext)
Hier hoeft het niet. De context die verwijderd wordt, is net aangemaakt.

* Perspectives.CollectDomeinFile.domeinFileFromContext
	- sub recursiveCollect: hier moet tryGetPerspectEntiteit gebruikt worden, want het gaat om de waarde van een binding en daar kan een referentie zijn ingetikt naar iets dat niet bestaat.
	- sub saveContext: hier hoeft het niet.

* Perspectives.ComputedTripleGetters.typeCheckerMessagesM
Hier hoeft het niet.

* Perspectives.ContextRolAccessors.getContextMember en getRolMember.
Ik vind het lastig om te beslissen of hier stil gefaald moet worden als de entiteit er niet is.

Nog te doen: Deltas, resource, prettyprinter.

OPNIEUW
In feite constitueert parseAndCache een test. Niet alleen wordt bepaald of de file syntactisch klopt, er wordt - kennelijk, en niet bedoeld - óók gezocht naar entiteiten die niet worden gevonden. Dat moet logischerwijs
	(a) ofwel een verwijzing naar een niet-bestaande entiteit in de te parseren file zijn,
	(b) ofwel een verwijzing naar een niet-bestaande entiteit in een ander model.
In dit speciale geval gaat het om (a), want de code probeert de te parseren file in te lezen uit couchdb. 
Wat ik eigenlijk wil is dat zo'n fout netjes gemeld wordt.
Dat kan door retrieveDomeinFile te laten falen met een adequate boodschap en door getPerspectEntiteit en getAVarRepresentingPerspectEntiteit óók te laten falen, waardoor een boodschap ontstaat met de naam van de domeinfile èn de entiteit. Dan dekken we beide gevallen (a) en (b).

KLAAR: BETERE FOUTMELDINGEN
Het probleem is nu: tijdens parsen probeert het systeem
	model:TestBotActie$Test$v1_buitenRol
uit couchdb op te halen, maar dat lukt natuurlijk niet.
1. Waarom en waar probeert ie dat?
2. Waarom is die rol niet in cache beschikbaar?

tba:Test$binnenRolBeschrijving$v1

Ik had de verwijzing in $propsEqual naar $v1 en $v2 niet goed!

=========== SEMANTISCHE FOUTEN
(IncorrectBinding) In de context 'model:TestBotActie$Test$binnenRolBeschrijving' is de Rol 'model:TestBotActie$Test$binnenRolBeschrijving$rolProperty_4' gebonden aan 'model:TestBotActie$Test$binnenRolBeschrijving$propsEqual'(type: 'model:QueryAst$nAryCombinator') maar moet worden gebonden aan een instantie van type 'model:Perspectives$Property'.
------
(MissingRolInstance) De verplichte Rol 'model:Perspectives$Context$binnenRolBeschrijving' komt niet voor in de context 'model:TestBotActie$Test$binnenRolBeschrijving$propsEqual'.
------
(MissingRolInstance) De verplichte Rol 'model:Perspectives$Context$buitenRolBeschrijving' komt niet voor in de context 'model:TestBotActie$Test$binnenRolBeschrijving$propsEqual'.
------
(MissingRolInstance) De verplichte Rol 'model:Perspectives$Context$binnenRolBeschrijving' komt niet voor in de context 'model:TestBotActie$Test$binnenRolBeschrijving$propsEqual$n1'.
------
(MissingRolInstance) De verplichte Rol 'model:Perspectives$Context$buitenRolBeschrijving' komt niet voor in de context 'model:TestBotActie$Test$binnenRolBeschrijving$propsEqual$n1'.
------
(MissingRolInstance) De verplichte Rol 'model:Perspectives$Context$binnenRolBeschrijving' komt niet voor in de context 'model:TestBotActie$Test$binnenRolBeschrijving$propsEqual$n2'.
------
(MissingRolInstance) De verplichte Rol 'model:Perspectives$Context$buitenRolBeschrijving' komt niet voor in de context 'model:TestBotActie$Test$binnenRolBeschrijving$propsEqual$n2'.

TODO
1. Geef in de definitie van psp:Rol de RolInContext $rolProperty als mogelijke binding een psp:Sum waardoor ook q:nAryCombinator goed is! D.w.z. psp:Function.
KLAAR
2. Geef de context $propsEqual het prototype psp:ContextProtoType.
3. Idem voor $n1 en $n2


PROPERTYNAAM OF GETTER?
In de rol $condition van psp:Actie had ik een getter staan, maar daar was een probleem mee (type binding). Nu heb ik hem vervangen door de naam van de property die ik de getter liet ophalen. Is dat correct?

dus:
	tba:Test$binnenRolBeschrijving$propsEqual
in plaats van
	--q:PropertyGetter $propsEqual1
	  --prototype psp:ContextPrototype
	  --extern $functionName = "constructInternalPropertyGetter"
	  --$property => tba:Test$binnenRolBeschrijving$propsEqual


Idem voor deze definitie:
        q:nAryCombinator $propsEqual
          prototype psp:ContextPrototype
          extern $functionName = "equal"
          $operand (1) =>
            q:PropertyGetter $n1
              prototype psp:ContextPrototype
              extern $functionName = "constructInternalPropertyGetter"
              $property => tba:Test$binnenRolBeschrijving$v1
          $operand (2) =>
            q:PropertyGetter $n2
              prototype psp:ContextPrototype
              extern $functionName = "constructInternalPropertyGetter"
              $property => tba:Test$binnenRolBeschrijving$v2

Kan ik dat vervangen door:

        q:nAryCombinator $propsEqual
          prototype psp:ContextPrototype
          extern $functionName = "equal"
          $operand (1) => tba:Test$binnenRolBeschrijving$v1
          $operand (2) => tba:Test$binnenRolBeschrijving$v2

Ik denk het niet. Want nAryCombinator wordt afgehandeld door constructQueryFunction toe te passen op de operands. Maar die functie moet een description van een query als argument krijgen.


Het gaat om een PropertyGetter, maar de te getten property is een calculated property. Kan dat? Ja, de functionName moet dan "propertyQuery" zijn.

$propsEqual1 (q:PropertyGetter) en daar $property van. Het toegestane binding type is psp:Property, maar ik bind hier aan $propsEqual en dat is een q:nAryCombinator.
Oftewel: hoe construeer je een functie die een berekende property ophaalt?

Zie constructQueryFunction, regel 87.

model:QueryAst$PropertyGetter$property$propertyOrFunction

ASPECTROL NIET GEVONDEN
De psp:Context q:ComputedRolGetter heeft psp:Rol als aspect. Hij geeft zelf een buitenRolBeschrijving, die hij als aspectRol de buitenRolBeschrijving van psp:Rol geeft. De naam daarvan is psp:Rol$buitenRolBeschrijving, maar die wordt door de checker niet gevonden: de melding is: 
	 maar die is niet beschikbaar in de Aspecten van 'model:QueryAst$ComputedRolGetter'
Terwijl dat dus duidelijk wel zo is (psp:Rol heeft wel degelijk een buitenRolBeschrijving).

0. Controleer of psp:Rol een buitenRolBeschrijving heeft.
	JA, HIJ IS IN DE FILE AANWEZIG
1. Waar wordt deze melding gegenereerd?
	In Perspectives.TypeDefChecker.checkAspectOfRolType

Opbouw van de melding:
	AspectRolNotFromAspect cid aspectRol ctype
	(AspectRolNotFromAspect rn arn cid)
	"(AspectRolNotFromAspect) De Rol '" <> rn <> "' gebruikt de Rol '" <> arn <> "' als aspectrol, maar die is niet beschikbaar in de Aspecten van '" <> cid <> "'."
	
	(AspectRolNotFromAspect) De Rol 'model:QueryAst$ComputedRolGetter$buitenRolBeschrijving' gebruikt de Rol 'model:Perspectives$Rol$buitenRolBeschrijving' als aspectrol, maar die is niet beschikbaar in de Aspecten van 'model:QueryAst$ComputedRolGetter'.
	
	ctype = model:QueryAst$ComputedRolGetter

De aspectRollen waarin wordt gezocht, worden bepaald met:

	(ctype ##= aspectenDefM >-> rollenDefM)

OPGELOST. buitenRolBeschrijving is geen rolInContext en kan dus niet als aspectRol binding gebruikt worden!