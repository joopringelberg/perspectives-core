CRL EDITING
Wat hebben we minimaal nodig om een CRL model enigszins comfortabel in couchdb te krijgen?

1. File upload gevolgd door parsing, gevolgd door semantic checking. 
2. Parsing leidt tot interne representatie; dan moet nog worden geserialiseerd naar een modelbestand en dat moet worden opgeslagen.
3. De core heeft nu alleen een query-interface. Hoe pers ik bovenstaande daarin?

AANPAK
1. Representeer een tekst.
	- property text is een string
	- calculated property parseState is een Boolean. Zodra 'text' veranderd, wordt parseState opnieuw berekend.
	- calculated property parseMessages is een string die begint met "nog niet geparseerd". Zodra 'text' veranderd, wordt parseMessages opnieuw berekend door de parser toe te passen en de messages met show om te vormen tot een string.
2. Calculated property semanticState is ook een string.
	- het resultaat van semantic checking wordt middels show opgeslagen in semanticState.
	- semanticState is "Semantische controle niet mogelijk" zolang parseState false is.
3. We hebben een interface nodig met:
	- een file select button en de weergave van de geselecteerde file.
	- een upload button
	- de weergave van parseMessages
	- de weergave van semanticState
	- een save button
4. We hebben in het protocol naar de Core de mogelijkheid nodig om een property een waarde te geven.
5. We hebben de mogelijkheid nodig om een calculated property af te laten hangen van twee andere (semanticState hangt namelijk af van parseState en text). NEEN, overbodig.
6. Als de upload button geklikt wordt, dan moet er een instantie gemaakt worden van ct:Text met de property sourceText gelijk aan de geuploade-file. Deze sourceText is client-side beschikbaar. We moeten dus in staat zijn om vanuit de client een context aan te maken en daar een property van te zetten.

UITWERKING parseMessagesM
1. De property parseMessages moet een computed triplegetter zijn. Zie module Perspectives.ComputedTripleGetters. We gebruiken daar de functie constructTripleGetterWithArbitrarySupport voor. KLAAR
2. Merk op dat deze computed triplegetter meegenomen moet worden in addComputedTripleGetters. KLAAR
2. Representatie van tekst. Ik gebruik een ad hoc model, niet TRL. KLAAR

TEST VAN PARSEMESSAGESM
1. In een testfile, maak een context S van type ct:Text. Lees de file politie.crl in en maak de tekst de waarde van de sourceText property van S. Vraag dan de property parseMessages op.

VOLTOOID:
	- parserMessages
	- syntacticState
	- typeCheckerMessages
	- semanticState

VERDER
1. Probeer de mutatieserialisatie die ik heb ontworpen voor delta's te hergebruiken voor mutatie over TCP en de interne API.
2. We hebben 'native' side effects nodig om een bestand op te kunnen slaan. Dit zijn purescript functies met Effect die niet een theorieverandering zijn.
	- sla de file op in couchdb
	- zet de timestamp 
	Voeg een berekende property toe: is opgeslagen na de laatste verandering? Hiertoe moeten we nog een timestamp modelleren, namelijk het moment van wijzigen. Als we de tekst zetten, vanuit de client, moeten we ook deze timestamp zetten.

MAAR: dit zou ook client side kunnen, met state in een component. Wat is beter? Het is client side wel eenvoudiger. Moet deze informatie bewaard blijven tussen sessies?
	
CONTEXTEN MAKEN VANUIT DE CLIENT
1. Breid het protocol van de API uit.
2. Maak functies aan de javascript kant.

In de client heb ik nu een component nodig
	- met state waaraan je kunt zien of er al een context gemaakt is voor een bepaalde tekst;
	- met een file select button en weergave van de geselecteerde file
	- met een upload button om opnieuw te parseren
	- met een 

3. Hoe kom je erachter of een context bestaat?
4. Hoe kom je bij de interne properties van een context?

================================================================================================
NAMESPACE VAN REACT COMPONENTS
De volgende componenten ontvangen een prop namespace:
* View
* Binding

De volgende componenten geven een prop namespace door aan hun subelementen:
* Context -> type van de Context
* Binding -> type van de Binding (van de Rol van de Context)

================================================================================================
Voorbereiding: maak handige functies om contexten en rollen te maken.
1. We hebben een protocol nodig vanuit Javascript en vanuit purescript. KLAAR
2. Vanuit javascript wil ik een json overdrachtsformat. KLAAR
3. Vanuit purescript wil ik een ADT. KLAAR

CONSTRUCTORS
ContextSerialization:
1. Controleer of al een context met de gegeven id bestaat.
2. Controleer of het type bestaat en een Context representeert.
3. Controleer of elk type rol (de sleutel van de StrMap) een rol bij het context type is.
4. Controleer of elk type property (de sleutel van de StrMap) van de interneProperties gedefinieerd is als property van de binnenrol van het contexttype.
5. Idem voor de externe properties.

RolSerialization

IDEE:
1. Maak de context en rollen
2. Laat de typedefchecker erop los.
KLAAR!

================================================================================================
COMPUTEDPROPERTYGETTER BESTAAT NOG NIET
ComputedPropertyGetter zou de pendant van ComputedRolGetter zijn. 
VOLTOOID.

CATCH 22
1. Ik moet query.crl veranderen (ComputedPropertyGetter toevoegen).
2. Daarvoor moet ik een modelfile kunnen parseren en saven.
3. Maar daar heb ik functionaliteit voor nodig die deze verandering vooronderstelt...

Mogelijke aanpak:
- maak ad hoc upload- en save functionaliteit.
Wat is nodig:
- lees file van disk
- parseer de file
- bij succes: sla op in couchdb.
Kan dit in een test?
Ja, sterker nog, ik heb al zo'n test gemaakt! Wel eerst de versie in couchdb weggooien.

REFACTORING
Is:
	(createContextWithSingleRole contextId (q "propertyQuery") pn)
hetzelfde als:
	(createPropertyGetterDescription contextId "propertyQuery" qn)
(waar qn en pn qualified names zijn)
Neen.