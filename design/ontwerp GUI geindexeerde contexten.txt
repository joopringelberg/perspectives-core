ONTWERP GUI GEINDEXEERDE CONTEXTEN

1. Elk model kan een 'geindexeerde context' hebben. Voorbeelden zijn: MijnSysteem en MijnRelayServers. Dit zijn contexten die door alle gebruikers aangemaakt worden en toch dezelfde identifier hebben. Het zijn contexten waar alléén de gebruiker een rol bij speelt, zodat ze nooit aan anderen kenbaar gemaakt worden.

2. De applicatie InPlace heeft een GUI waarvan de hoofdindeling gevormd wordt door de lijst van geïndexeerde contexten. Deze lijst vormt het startpunt voor de gebruiker. Elk element van de lijst is als het ware een applicatie.

3. Geïndexeerde contexten zijn gebonden in de rol psp:PerspectivesSysteem$geïndexeerdeContexten. Later kan ik een betere naam kiezen.

4. Elk model heeft een type dat de beschrijving geeft van de geïndexeerde context van dat model. Voor elk model X is de identifier van dat type model:X$GeïndexeerdeContext. Dit type - een Context - heeft op de buitenrol de properties 'auteur' en 'beschrijving'.

5. De computed rol psp:PerspectivesSysteem$modellen verander ik zodanig dat hij voor elk model de identifier van de GeïndexeerdeContext van dat model oplevert.

6. Ik voeg de rol psp:PerspectivesSysteem$modellenInGebruik toe. Deze rol heeft als binding een geïndexeerde context. Ik laat nog even in het midden of we dergelijke rollen een gezamenlijk aspect geven. Een mogelijke property is 'inGebruikSinds'.

7. psp:PerspectivesSysteem krijgt een Actie waarvan de bot het subject is. De conditie van deze Actie is:
	* er is een instantie van de rol psp:PerspectivesSysteem$modellenInGebruik met binding X
	* maar er is geen instantie van de rol psp:PerspectivesSysteem$geïndexeerdeContexten met een binding waarvan het type X is
Het effect van deze actie is:
	* er wordt een instantie van psp:PerspectivesSysteem$geïndexeerdeContexten gemaakt
	* er wordt een instantie van model:X$GeïndexeerdeContext gemaakt
	* de buitenRol van deze instantie wordt gebonden in de zojuist aangemaakte rolinstantie.

8. Ik maak in InPlace een scherm voor de context MijnSysteem met de volgende indeling:
	* de rol psp:PerspectivesSysteem$modellen is zichtbaar als een lijst van Views op de buitenRol waarin 'auteur' en 'beschrijving' te zien zijn.
	* daarnaast is de rol psp:PerspectivesSysteem$modellenInGebruik zichtbaar.
	* een model kan naar de modellen in gebruik gesleept worden. Dan wordt een nieuwe rol aangemaakt en gebonden.
Door een model in gebruik te nemen, wordt de actie gestart die de geïndexeerde context van het model maakt.
Hierdoor verschijnt in de hoofdindeling de geïndexeerde context van het zojuist in gebruik genomen model.

VORMGEVING
Ik zou links een paneel willen hebben met daarin de namen van de geïndexeerde contexten. Klik je erop, dan wordt het rechterdeel van het scherm gevuld door het scherm van die context. Dit roept drie vragen op:
1. Hoe zorg ik ervoor dat klikken een scherm opent?
2. Waar zet je het nieuwe scherm neer en wat doe je met wat er daarvoor stond?
3. Hoe laad je met React dynamisch een nieuwe component?

Ik zou als standaard gedrag willen dat als je klikt op iets dat een context representeert, je het scherm voor die context opent.
Zolang ik schermen met de hand bouw, weet ik precies wat een context representeert.
Ik kan een React component maken voor een context. In die component bouw ik het open-bij-klikken gedrag in. Ik noem dat een Kaartje.

Voorlopig ga ik uit van een simpel schema voor schermen:
	* het begint bij een geïndexeerde context
	* als je binnen het scherm voor een context op een kaartje klikt, open je het scherm voor de betreffende context *op dezelfde plek*
	* als je een scherm sluit, *kom je in het vorige scherm*
	* als je een geïndexeerde context opent, sluiten alle openstaande schermen.

We krijgen dus state van de GUI. Ik ga er vooralsnog vanuit dat die in het proces van de GUI zelf opgeslagen wordt. Dus als je InPlace sluit en heropent, begin je weer bij een leeg scherm.

DYNAMISCH LADEN
Dynamisch laden kan (bijvoorbeeld) met react-loadable (https://www.npmjs.com/package/react-loadable), zoals beschreven in https://itnext.io/react-loading-components-dynamically-a9d8549844c4.

Om dit te kunnen gebruiken, moet je een Component die je wil bijladen, in een apart bestand onderbrengen. Je laadt een component via zijn bestandsnaam.
Ergo, een scherm wordt een component in een apart bestand met een unieke naam.

Een applicatie wordt dan de combinatie van een Model en een Javascript bestand dat een React component beschrijft, één voor elke Context in het model met een uniek scherm. Het ligt voor de hand om het scherm/bestand dezelfde naam te geven als de Context (of minstens beide automatisch op elkaar te kunnen afbeelden).


Als je een model download van de repository, moet je ook de javascript bestanden ophalen en die op een voor de client bereikbare plek opslaan.
We kunnen bij het model in Couchdb de schermbestanden als attachments opslaan. Een attachment haal je op met deze uri:

	/{db}/{docid}/{attname}

db is standaard ('perspect_models'). docid is de modelnaam (b.v. 'model:Perspectives'). En attname is gelijk aan de contextnaam (waarbij ik de modelkwalificatie kan weglaten). Oftewel, je kunt aan de React kant heel goed de uri samenstellen uit de gekwalificeerde naam van de context waar je een scherm voor wil laten zien. De host is natuurlijk 'localhost:5984'.

Resteert één probleem, namelijk de locatie van de schermbestanden tijdens ontwikkeling. Je bewerkt bestanden die volgens ontwikkellogica zijn ondergebracht in een sourcetree. Eigenlijk zou ik een automatisch proces moeten maken dat telkens als zo'n bestand verandert, het uploadt naar Couchdb.

Dit kan niet met Webpack. We hebben een of andere task runner nodig, zoals Gulp of Grunt. Er is geen specifieke task runner voor Purescript. Ik denk dat ik met Gulp moet werken.

1. Hoe herkent de task runner de files hij moet onderbrengen in Couchdb?
2. Hoe weet hij wáár ze moeten worden opgeslagen? Dus als attachment van welk model?

Ad 1. Het ligt nogal voor de hand om een directory voor een model te maken, in het project. De inhoud van die directory moet worden opgeslagen. We brengen die directories per model onder in een root directory: modelScreens, of apps.
Ad 2. Als we de directory de naam van het model geven, gaat het goed (als de task runner die naam kan oppakken). De bestanden moeten de namen van de afgebeelde contexten dragen.

Overigens: source files moeten nog wel door Webpack getransformeerd worden (JSX enzo). Het schijnt dat Webpack automatisch aparte bundles maakt voor delen die dynamisch geladen worden (automatic code splitting: zie: https://webpack.js.org/guides/code-splitting/).
Dat betekent weer dat de task runner deze output daar moet oppakken en in couchdb moet zetten. 



