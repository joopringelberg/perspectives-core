React heeft dataflow één kant op - naar de schermen. Die flow verloopt door zogenaamde 'props' van een component een waarde te geven. Als je een component als een functie beschouwt, is een prop een parameter. Je kunt pure componenten ook als functie implementeren. Een component kan ook state hebben. Die bouw je op uit de waarden van de props.

Als de gebruiker b.v. een veld invult, wordt je geacht daarachter code te hebben hangen die op de één of andere manier de state van een React component verandert. State zit vaak hoog in de component tree en vloeit van daaruit weer naar de blaadjes. 

In combinatie met Perspectives kun je zeggen dat de meeste - zo niet alle - state door Perspectives wordt bijgehouden. We hebben dan dus twee dingen nodig om Perspectives en React te verbinden:
	- flow vanuit Perspectives naar component state
	- de mogelijkheid om in componenten acties (met zij-effecten) te instantiëren.
Voor de eerste zou het b.v. heel natuurlijk zijn om een view op een rol te mappen op de props van een component. Sterker, je zou de props van een component willen modelleren naar een view en dan de verbinding leggen. Dat zou een stukje van de React bindings voor Perspectives kunnen zijn.

Je zou je kunnen voorstellen dat we een RolComponentFactory aanbieden. Die roep je aan met een Rol (type) en een View. Je hebt dan een Component met props gedefineerd die verbonden zijn met Perspectives.

Het begint met een raadpleegt-actie. Als je een Context raadpleegt vanuit een Rol (de rol die de Gebruiker vult in die Context), dan...
... dan wat? Een Context heeft alleen Rollen en die kun je op zich niet zien.
Bij React-Redux maken ze verschil tussen container- en presentatiecomponenten. Een Context-component zou typisch een container zijn.

Met welke rollen? Om een binding met Perspectives tot stand te brengen, hebben we queries op de rollen van een context nodig (we kunnen alleen abonneren op queryresultaten die in de triplestore worden bijgehouden). Is het mogelijk om te vermijden om in het wilde weg vanuit een container alle rollen op te vragen?

Uiteindelijk gaat het om de acties die in subcomponenten van de Context container worden uitgevoerd. Dat zijn allemaal acties van de rol die de gebruiker in die Context speelt.
Welke acties gaat de programmeur gebruiken?

Intermezzo. We moeten hier opletten: Perspectives raadpleegt-acties zijn geen acties in de zin zoals React en Redux ze opvatten.
Einde.

Een raadpleegt-actie op een bepaalde rol (met die rol als lijdend voorwerp) vereist een RolComponent. Een Raadpleegt-actie zal in een presentatie-component uitgewerkt worden. Als we nu eens een RaadpleegtContainer maken? Dat is een container met precies de props van de view op het lijdend voorwerp van die raadpleegt actie.
Ik vermoed dat een raadpleegt-actie altijd alleen maar een lijdend voorwerp heeft, geen meewerkend voorwerp. 'De properties' is daarom eenduidig, in dit verband.

Een Context container bevat dus een aantal Raadpleegt containers die elk één Rol vereisen. De Context container moet dus queries opstellen voor elk van die rollen.

Intermezzo. Merk op dat de rol van een context niet functioneel hoeft te zijn, dus dat een context-instantie meerdere instanties van dezelfde rol kan hebben.
Einde.

Intermezzo. Stel dat de Perspectives ontwikkelomgeving react containers kan genereren voor, bijvoorbeeld, acties. Dat zijn codebestanden die in de GUI ontwikkelomgeving ge-required kunnen worden. Al naar gelang de kwaliteiten van de ontwikkelomgeving kan de programmeur dan (b.v. middels autocomplete) zien welke properties in zo'n container beschikbaar zijn.

Voor een functionele en een relationele rol worden dan verschillende containers gegenereerd. De relationele rol biedt een iterator over instanties, waarbij elke instantie properties heeft. Of misschien itereert de relationele rol over de functionele.
Einde.

Door PropTypes (https://reactjs.org/docs/typechecking-with-proptypes.html mee te genereren, ondersteunen we type checking in de ontwikkelomgeving (WebStorm ondersteunt dit).

1. Kunnen we het zo maken dat de Context container rolqueries aanmaakt op basis van de Raadpleegt containers die de programmeur erin genest heeft?
2. En hoe zit het met andere acties?

Raadpleegt containers verbinden met Context containers.
Een Raadpleegt container wordt gegenereerd op basis van het type van de actie en vooral de view. De (gegenereerde) implementatie zal voor elke property in de view een property-query opstellen en die verbinden met een member van de props van de component.
Maar de container moet de *instantie* van de rol als argument aangeboden krijgen.
Waar haalt de Context container die instantie vandaan?

We zouden de Context container kunnen genereren met voor èlke rol een gelijknamige functie, die, indien uitgevoerd, een query op die rol opstelt en daaraan een callback koppelt die setState gebruikt om een gelijknamige property met de rolinstantie(s) te vullen. De functie kan tevens een promise van de instantie opleveren waarbinnen de programmeur die instantie kan doorgeven aan een RaadpleegtContainer. Hierdoor verbindt de programmeur de Context- met de Raadpleegt Container. De functie hoeft niet te memoriseren: dat doet de Perspectives Triple Administration.

Dus zoiets:
	this.aangeverRol().then(a => <RaadpleegtContainer rolinstance=a>)

3. Hoe is de verbinding tussen een query resultaat in de triple administratie en React? Loopt dat via setState (en dus state van een component)? Of verander je rechtstreeks de props? Neen. Props are read-only!
Een container component moet dus state hebben en die state wordt veranderd vanuit de triple administratie. We hebben dus de notie van subscription op een query resultaat nodig en de subscriber roept setState aan.

ARCHITECTUUR: DEVELOPMENT EN DEPLOYMENT
1. Perspectives wordt een Electron App en krijgt daarmee toegang tot het filesysteem.
2. We volgen de aanbevolen development-, build- en deployment structuur van Electron.
3. Pulp builds plaatsen we in de build structuur van Electron.
4. We gaan de Gui maken met React, in Webstorm.  Hier zal ook een development structuur zijn. Misschien moeten we dit afstemmen op de structuur van Electron. De Gui builden we naar de build structuur van Electron. NB: iemand heeft dit gedaan: https://medium.freecodecamp.org/building-an-electron-application-with-create-react-app-97945861647c.
5. Perspectives kan mogelijk in de toekomst React componenten genereren. Omdat Perspectives een lokale app is kan hij deze componenten als js files opslaan in de development structuur van Webstorm.

VRAGEN
1. Ondersteunt WebStorm Electron? JA: zie https://blog.jetbrains.com/webstorm/2016/05/getting-started-with-electron-in-webstorm/.
2. Wat zijn de aanbevolen IDE's voor Electron?
3. Hoe is de development/build structuur voor Electron?
4. Hoe werkt create-react-app en wat bouwt het op? Zie: https://github.com/facebook/create-react-app.

Links:
https://blog.jetbrains.com/webstorm/2016/05/getting-started-with-electron-in-webstorm/.
https://medium.freecodecamp.org/building-an-electron-application-with-create-react-app-97945861647c
https://github.com/facebook/create-react-app
https://www.slightedgecoder.com/2017/12/03/loading-react-components-dynamically-demand/

DYNAMISCH EEN COMPONENT LADEN
Het kan, met import().
Voor uitleg zie: https://hospodarets.com/native-ecmascript-modules-dynamic-import
en:
https://www.slightedgecoder.com/2017/12/03/loading-react-components-dynamically-demand/


PERSPECTIVES STATE
Perspectives bouwt state op tijdens executie. We willen Perspectives aanroepen uit React Js code en we willen dat tussen deze aanroepen state door Perspectives bewaard blijft. Daarmee bedoel ik niet dat die state naar Couchdb gepersisteerd moet worden, maar dat state in memory bewaard blijft.

Wat voor architectuur voldoet aan die eis?

Als Perspectives een http server zou zijn, zouden de React code als http client met Perspectives kunnen communiceren. 

Als Perspectives in een webworker zou draaien, zouden we de messaging van en naar webworkers kunnen gebruiken.

Is er nog een andere manier? Kunnen we een object met dispatch uit Perspectives verkrijgen?

Er is een interface naar de node command line. Dat is een soort source voor events, die strings opleveren. purescript-node-readline heeft de createConsoleInterface functie, die een interface oplevert waar we een lineHandler aan kunnen binden middels setLineHandler.
Zoiets zou ik willen, al lijkt dit vooral communicatie naar Perspectives toe te leveren. Dit zou aangevuld moeten worden met een javascript functie die 'schrijft' naar de interface zodat de lineHandler de boodschappen kan analyseren. Als via deze functie ook callbacks aangeboden kunnen worden die Perspectives gebruikt, zijn we klaar.

Er zijn natuurlijk meer interfaces naar events uit de 'omgeving'. Halogen werkt daarmee.

Een idee: representeer de React Gui code als een geïmporteerde computation in Aff. Fork die Aff. Representeer Perspectives eveneens als een geforkte Aff. Laat beide beschikken over dezelfde AVar. 
De Gui kan daar een structuur in schrijven met een query en een callback. De query wordt uitgevoerd en de callback wordt aan het resultaat gehangen.
Dit is de richting Gui->Perspectives.
Gebruik een andere AVar om acties te instantiëren. Dit heeft dezelfde opzet: een representatie van de actie en een callback die voorzien wordt van het lijdend voorwerp van de geïnstantieerde actie.

De vraag is natuurlijk hoe de Gui code de AVar moet vullen en moet lezen. Vullen kan ik me nog voorstellen: je geeft een functie mee die zijn argument in de AVar stopt. Maar lezen is een andere zaak. Of: getvar en dan een callback?
Dus: roep de gui-functie-in-Aff aan met twee argumenten:
	- een functie om de AVar te vullen
	- een functie om een callback aan de purescript kant te geven die toegepast wordt als getVar een waarde oplevert.
De gui-kant bewaart de vul-functie en roept onmiddelijk de andere aan met zijn callback. Dat wordt dan een soort promise, denk ik.
Je zult dan voor de volgende ronde weer zoiets moeten doen. Er moet immers telkens een nieuwe promise aan de gui kant worden gemaakt. Dus wat er terugkomt naar de gui als de avar is gevuld, is een waarde en dezelfde functie waarmee de callback weer aan Purescript kan worden gegeven.


ONTWERP INTERFACE PERSPECTIVES - REACT GUI
1. De programmeur van een React Gui voor Perspectives werkt met vier container componenten: ContextContainer, RolContainer, ContextProxyContainer en ViewContainer. 

2. De eerste drie componenten hebben state. 
	- ContextContainers hebben in hun state property (this.state) een property voor elke rol die in de gui voor de context gebruikt wordt. De waarde daarvan is een RolID voor een functionele rol en een array van RolIDs voor relationele rollen.
	- RolContainers hebben een property 'rolID' op hun state.
	- ContextProxyContainers zijn als RolContainers.

ViewContainers hebben een property op hun props voor elke property in de view. Geen state.
	
3. Context-, Rol- en ContextProxyContainer worden geïnitialiseerd met een Perspectives ID. De ViewContainer wordt geïnitialiseerd met een object met property-values. Dit wil zeggen dat de props deze properties bevatten.

4. Een ContextContainer wordt specifiek voor een bepaalde gemodelleerde Context gegenereerd door Perspectives, als .js file. Een ContextContainer is een Class (want dit soort containers heeft state) en heeft een memberfunctie voor elke rol in die Context. De programmeur past die functie toe in de constructor van de ContextContainer als hij een RolContainer voor die rol wil opnemen. Toepassing van die functie
	- zorgt ervoor dat in Perspectives een Query wordt uitgevoerd die de rol-instanties oplevert;
	- zorgt ervoor dat bij het query resultaat een javascript callback wordt geregistreerd die bij verandering van het query resultaat de ReactJs setState functie aanroept op de gelijknamige state property van de ContextContainer. 
In de render functie moet de programmeur de RolContainer expressie alleen onderdeel van het resultaat maken, als de Container state de rol (al) bevat. Dit is dus standaard boilerplate. Als we elke rolfunctie de property al laten aanmaken met de waarde null, kunnen we een standaard 'readyToRender' functie maken die true levert als alle rollen aanwezig zijn (die itereert over de own properties van state en levert true als ze allemaal niet null zijn). Op die manier kun je de render functie conditioneel maken op één functioneel resultaat.

5. De ContextContainer heeft voor elke RolInContext die gebonden is aan een BuitenRol van een andere Context, twéé functies:
	- de functie met de rolnaam levert de buitenrol. Deze kan gebruikt worden om een ContextProxyContainer te maken;
	- een functie met de naam <rolnaam>_context. Deze kan gebruikt worden om een ContextContainer aan te maken. Deze functie leidt tot een query die 'doorprikt' naar de context van de buitenrol.

	1. Kan je in een promise een ReactJs component aanmaken?
		ANTWOORD: een promise is onnodige overhead.
	2. Hoe neem je functies op bij een Component met state? 
		ANTWOORD: Een Component is een JS Class en die heeft member functies.

6. Een RolContainer wordt voor een bepaalde gemodelleerde rol gegenereerd door Perspectives. Zo'n container heeft een functie voor elke view op de Rol die is gemodelleerd. De programmeur past één of meer van deze functies toe in de constructor:
	- waardoor op de state van de RolContainer een property verschijnt met de naam van de view die gebonden is aan een object met alle properties die in de view voorkomen
	- zodat in Perspectives een query wordt uitgevoerd op alle properties in de view en het resultaat wordt verzameld in een record dat middels een callback en de functie setState in de gelijknamige property van de state van de RolContainer wordt geschreven.
Zoals bij de ContextContainer moet de render functie viewContainers alleen renderen als hun corresponderende state property gevuld is.

7. Een ViewContainer heeft geen state. Alle property waarden zijn in de props van de component terug te vinden.

8. Als een Container wordt opgeruimd, moet(en) de callback(s) bij de betreffende quer(y)(ies) worden uitgeschreven. Als de Container een rol-functie aanroept, krijgt hij van Perspectives een Promise van een functie terug waarmee dat kan. De Container bewaart deze functie. Hij levert een promise met een true/false waarde door aan de programmeur. Dus zo:
	<rol-naam>().then( unsubscriber => contextContainer.state.unsubscribers.<rol-naam> = unsubscriber)
De functie wordt gegenereerd met unRegisterTriple, toegepast op de referentie die wordt verkregen uit toepassing van addEffectToQuery.

9. De aanroep naar Perspectives levert een promise, die ook kan eindigen in falen. Dus de aanroep van 'then' moet een rejectionHandler meenemen. De meegekregen foutmelding moet in het standaard foutkanaal van de Gui terechtkomen.

	3. Foutafhandeling. (Hoe) kan Perspectives een foutmelding doorspelen aan het React-deel? Hoe pakt dat uit in de promises? Wat doet het React-deel met een doorgespeelde fout?
		ANTWOORD: De syntax is: <promise>.then( fullFillmentHandler, RejectionHandler ). Een fout in Perspectives hoeft dus niet tot een fout in React te leiden. We kunnen de Perspectives fout beheerst het foutkanaal van de gui insluizen, of opnieuw een error gooien.
	4. Hoe verloopt de tear-down van een React component? Wat is het haakje waarin we de unsubscribe functie van Perspectives kunnen hangen?
		ANTWOORD: met de componentWillUnmount() functie.

10. Hoe komt een ContextContainer tot stand en hoe verkrijgt hij zijn ContextID?
Een RolInContext kan gebonden zijn aan een andere RolInContext en dan moet de programmeur een RolContainer inzetten. Maar hij kan ook gebonden zijn aan een BuitenRol en dan heeft de programmeur de keuze uit twee containers:
	- de ContextProxyContainer: dan gebruikt hij de functie <rolnaam>;
	- de ContextContainer: dan gebruikt hij de functie met de naam <rolnaam>_context.
Welke container ingezet wordt, is aan de programmeur.

11. De ContextProxyContainer geeft alleen toegang tot de buitenrol van de Context. Hij is functioneel gelijk aan een RolContainer. In een ContextProxyContainer kan de programmeur dus ViewContainers opnemen. De ContextProxyContainer heeft één extra property en dat is 'context'. Deze property kan worden gebruikt om een ContextContainer mee te initialiseren.
NOTA BENE. Dit is waarschijnlijk alleen van belang voor de afhandeling van een interface waarin de eindgebruiker in staat wordt gesteld om, vanuit de weergave van de proxy, de context zelf te openen ('doorklikken').

DE PERSPECTIVES API
Perspectives is het hoofdprogramma.
1. Perspectives roept een callback van de in javascript geschreven proxy voor Perspectives aan en zet zo een communicatiekanaal op.
2. Over dit kanaal kan met een beperkt aantal functies gecommuniceerd worden.

De rol- en view functies maken gebruik van deze API. 
Een eerste benadering van het type van bijvoorbeeld de functie om een rol te verkrijgen, is:
	getRol :: ContextID -> RolName -> ReactStateSetter -> Aff (QueryEffects e) QueryUnsubscriber

Merk op dat getRol de functie runPerspectives zal moeten gebruiken om van MonadPerspectives naar Aff te komen.

Het resultaat moet in een promise worden opgeleverd. Dus:

	getRol :: ContextID -> RolName -> ReactStateSetter -> Aff (QueryEffects e) (Promise QueryUnsubscriber)

Hier zijn twee types gebruikt, die bij eerste benadering luiden:

	ReactStateSetter :: Array ID -> Unit

	QueryUnsubscriber :: Unit

Maar de ReactStateSetter moet kunnen worden gebonden aan de tweede parameter van addEffectToQuery. Dat is een NamedFunction waarvan de functie het volgende type heeft:

	(Array String -> Eff (AjaxAvarCache (ref :: REF | e)) Unit)

Nemen we aan dat het verpakken als NamedFunction (tot een QueryEffect) aan de Perspectives kant gebeurt, dan moet het type van ReactStateSetter dus zijn:

	ReactStateSetter :: forall e. (Array String -> Eff (AjaxAvarCache (ref :: REF | e)) Unit)

Nu missen we nog één ding en dat is het effect op de GUI. Ik noem dat effect REACT, dus dan wordt het:

	ReactStateSetter :: forall e. (Array String -> Eff (AjaxAvarCache (ref :: REF, react :: REACT | e)) Unit)

ReactStateSetter moet GUI-side als parameter worden meegegeven. Daar heeft de functie natuurlijk een simpele javascript signatuur: Array ID -> undefined.

	5. Wat is de runtime representatie van Unit? 
		ANTWOORD: {}. Maar ik weet niet of gelijkheidstests vereisen dat we precies het lege object gebruiken dat in Data.Unit is vastgelegd.
	
	6. Hoe is undefined gerepresenteerd in Purescript?
		ANTWOORD: in Data.Foreign.NullOrUndefined, als 'undefined' en dat is daadwerkelijk de undefined waarde van Javascript. Maar dat is een waarde, geen type. We zouden NullOrUndefined kunnen gebruiken.

	7. Wat moeten we doen om deze types te verenigen?

Misschien moeten we uiteindelijk ReactStateSetter daarom zo typeren:

	ReactStateSetter :: forall e. Array String -> Eff (AjaxAvarCache (ref :: REF, react :: REACT | e)) NullOrUndefined

GUI-side moet deze functie als volgt geschreven worden om door Purescript als een waarde in Eff gezien te worden:

	function(idArray)
	{
		return function()
		{
			setState( <modifiy the state with idArray> );
		}
	}


QueryUnsubscriber zal een functie moeten zijn die gebruik maakt van functies die de TripleStore wijzigen. Er zijn nog geen verwijder functies, maar ik denk dat we nu wel kunnen vaststellen dat het type in elk geval zo moet zijn:

	QueryUnsubscriber :: Eff (gm :: GLOBALMAP | e1) Unit

Aan de GUI kant moeten we deze functie dus toepassen op een lege argumentenlijst, want het is een thunk. Dus: unsubscribe()().

QueryUnsubscriber moet door Perspectives gemaakt worden. Het is daar het resultaat van een functie die parameters neemt die aangeven wàt wáár uitgeschreven moet worden. Hij wordt gemaakt met:

	unRegisterTriple :: forall e1. TripleRef -> Eff (gm :: GLOBALMAP | e1) Unit

QueryUnsubscriber heeft dan dus het type Eff (gm :: GLOBALMAP | e1) Unit, dus dat klopt.

======================================================================================================
1. Perspectives importeert een foreign function 'connect'. Dit is een functie die de class PerspectivesProxy instantieert, die in javascript geprogrammeerd is en in de browser moet worden geïmporteerd. Deze instantie wordt in een variabele van window, pproxy, gebonden.
2. Connect krijgt aangeboden:
	- twee avars
	- een getter (gebaseerd op takeVar)
	- een setter
	Deze worden opgeslagen in de instantie van PerspectivesProxy.
3. PerspectivesProxy biedt functies aan om met Perspectives te communiceren.
4. Aan de Perspectives kant leest een dispatcher de avar uit. React stopt structuren in de AVar waarin een functienaam en de functieargumenten te lezen vallen.
5. De dispatcher voert de (gesanctioneerde) functies uit. Het resultaat gaat terug in de AVar.
6. De dispatcher werkt met een ADT waarin de mogelijke functies de onderscheiden constructoren zijn.
7. Voor de dispatcher zit een functie die een record omzet naar waarden van de ADT op basis van de functienaam.
8. De React kant kan dus gewone javascript objecten met functienaam en argumenten opsturen.

STRATEGIE
1. Vooralsnog laat ik Perspectives de authenticatie doen.
2. Uiteindelijk stellen we functies vanuit React aan Perspectives beschikbaar om de GUI voor de authenticatie te maken.

======================================================================================================














