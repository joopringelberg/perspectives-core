Op welk niveau moeten functies een naam hebben om de afhankelijkheden goed te administreren?

HUIDIGE SITUATIE
Waar namen gegeven worden:

In Location.purs:
	- memorizeMonadicFunction
In Property.purs:
	- getString(s)
	- getNumber(s)
	- getBoolean
	- getResource(s)
In PropertyComposition.purs:
	- memorizeSingleGetter
	- memorizePluralGetter
	- pToS (>>->)
	- pTop (>>->>)
In QueryCombinators:
	- cons
	- identity
	- hasValue
In SystemQueries.purs:
	- identifier
	- types
	- superClasses
	- typeSuperClasses

WANNEER MOET EEN FUNCTIE EEN NAAM HEBBEN?
In 
	- connectLocations
	- locationDependent
	- traverseLoc
	- memorizeMonadicFunction
	- in deze class instance functions van Location:
		- map
		- apply
		- bind

IS HET ZINVOL?
1. In memorizeMonadicFunction zeker wel.
2. In de get(Type>)(s) functies niet in directe zin. Er wordt niet in gememoriseerd.
3. In memorizeSingleGetter, memorizePluralGetter, pToS en pToP wel. Daar wordt gememoriseerd dmv traverseLoc.
4. QueryCombinators:
	- in cons wordt apply gebruikt op locations.
	- de identity functie moet een naam hebben.
	- hasValue mapt over een Location.
5. In SystemQueries:
	- identifier is een MemorizingSingleGetter en moet een naam hebben. NB QUERYSTAP?
	- types gebruikt memorizeMonadicFunction. De gegenereerde functie (QC.mclosure rdfType) moet dus een naam hebben. mclosure genereert een anonieme functie.
	- superClasses wordt gegenereerd door (QC.aclosure subClassOf). aclosure genereert een anonieme functie.
	- typeSuperClasses is een functie gegenereerd door >->> en die geeft geen naam.

LET OP
- mclosure gebruikt staartrecursie om telkens de volgende resource van de closure toe te voegen. Daarbij wordt gevalsonderscheiding gebruikt. 
Maar als de laatste SingleGetter verandert, wordt die verandering niet opgepikt, denk ik?
Bovendien wordt hier apply over Location gebruikt terwijl de functie in kwestie geen naam heeft.
